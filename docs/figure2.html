<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Ben Umans" />

<meta name="date" content="2024-07-29" />

<title>figure2</title>

<script src="site_libs/header-attrs-2.26/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<link rel="icon" href="https://github.com/workflowr/workflowr-assets/raw/main/img/reproducible.png">
<!-- Add a small amount of space between sections. -->
<style type="text/css">
div.section {
  padding-top: 12px;
}
</style>



<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">oxygen_eqtl</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="license.html">License</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">figure2</h1>
<h4 class="author">Ben Umans</h4>
<h4 class="date">2024-07-29</h4>

</div>


<p>
<button type="button" class="btn btn-default btn-workflowr btn-workflowr-report" data-toggle="collapse" data-target="#workflowr-report">
<span class="glyphicon glyphicon-list" aria-hidden="true"></span>
workflowr <span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span>
</button>
</p>
<div id="workflowr-report" class="collapse">
<ul class="nav nav-tabs">
<li class="active">
<a data-toggle="tab" href="#summary">Summary</a>
</li>
<li>
<a data-toggle="tab" href="#checks"> Checks <span
class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> </a>
</li>
<li>
<a data-toggle="tab" href="#versions">Past versions</a>
</li>
</ul>
<div class="tab-content">
<div id="summary" class="tab-pane fade in active">
<p>
<strong>Last updated:</strong> 2024-08-30
</p>
<p>
<strong>Checks:</strong> <span
class="glyphicon glyphicon-ok text-success" aria-hidden="true"></span> 5
<span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> 2
</p>
<p>
<strong>Knit directory:</strong> <code>oxygen_eqtl/</code> <span
class="glyphicon glyphicon-question-sign" aria-hidden="true"
title="This is the local directory in which the code in this file was executed.">
</span>
</p>
<p>
This reproducible <a href="https://rmarkdown.rstudio.com">R Markdown</a>
analysis was created with <a
  href="https://github.com/workflowr/workflowr">workflowr</a> (version
1.7.0). The <em>Checks</em> tab describes the reproducibility checks
that were applied when the results were created. The <em>Past
versions</em> tab lists the development history.
</p>
<hr>
</div>
<div id="checks" class="tab-pane fade">
<div id="workflowr-checks" class="panel-group">
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongRMarkdownfilestronguncommittedchanges">
<span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> <strong>R Markdown file:</strong> uncommitted
changes </a>
</p>
</div>
<div id="strongRMarkdownfilestronguncommittedchanges"
class="panel-collapse collapse">
<div class="panel-body">
<p>The R Markdown is untracked by Git. To know which version of the R
Markdown file created these results, you’ll want to first commit it to
the Git repo. If you’re still working on the analysis, you can ignore
this warning. When you’re finished, you can run
<code>wflow_publish</code> to commit the R Markdown file and build the
HTML.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongEnvironmentstrongempty">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Environment:</strong> empty </a>
</p>
</div>
<div id="strongEnvironmentstrongempty" class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! The global environment was empty. Objects defined in the
global environment can affect the analysis in your R Markdown file in
unknown ways. For reproduciblity it’s best to always run the code in an
empty environment.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongSeedstrongcodesetseed20220621code">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Seed:</strong>
<code>set.seed(20220621)</code> </a>
</p>
</div>
<div id="strongSeedstrongcodesetseed20220621code"
class="panel-collapse collapse">
<div class="panel-body">
<p>The command <code>set.seed(20220621)</code> was run prior to running
the code in the R Markdown file. Setting a seed ensures that any results
that rely on randomness, e.g. subsampling or permutations, are
reproducible.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongSessioninformationstrongrecorded">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Session information:</strong>
recorded </a>
</p>
</div>
<div id="strongSessioninformationstrongrecorded"
class="panel-collapse collapse">
<div class="panel-body">
<p>Great job! Recording the operating system, R version, and package
versions is critical for reproducibility.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongCachestrongnone">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Cache:</strong> none </a>
</p>
</div>
<div id="strongCachestrongnone" class="panel-collapse collapse">
<div class="panel-body">
<p>Nice! There were no cached chunks for this analysis, so you can be
confident that you successfully produced the results during this
run.</p>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongFilepathsstrongabsolute">
<span class="glyphicon glyphicon-exclamation-sign text-danger"
aria-hidden="true"></span> <strong>File paths:</strong> absolute </a>
</p>
</div>
<div id="strongFilepathsstrongabsolute" class="panel-collapse collapse">
<div class="panel-body">
<p>
Using absolute paths to the files within your workflowr project makes it
difficult for you and others to run your code on a different machine.
Change the absolute path(s) below to the suggested relative path(s) to
make your code more reproducible.
</p>
<table class="table table-condensed table-hover">
<thead>
<tr>
<th style="text-align:left;">
absolute
</th>
<th style="text-align:left;">
relative
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedcoarse_filtered_reharmonize_20240305.RDS
</td>
<td style="text-align:left;">
output/de_results_combinedcoarse_filtered_reharmonize_20240305.RDS
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_20240305.RDS
</td>
<td style="text-align:left;">
output/de_results_combinedfine_filtered_reharmonize_20240305.RDS
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_pseudoall_filtered_20231107.RDS
</td>
<td style="text-align:left;">
output/de_results_pseudoall_filtered_20231107.RDS
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_for_mash_20240731.RDS
</td>
<td style="text-align:left;">
output/de_results_combinedfine_filtered_reharmonize_for_mash_20240731.RDS
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedcoarse_filtered_reharmonize_for_mash_20240731.RDS
</td>
<td style="text-align:left;">
output/de_results_combinedcoarse_filtered_reharmonize_for_mash_20240731.RDS
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/fgsea/
</td>
<td style="text-align:left;">
output/fgsea
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_censored_20240802.RDS
</td>
<td style="text-align:left;">
output/de_results_combinedfine_filtered_reharmonize_censored_20240802.RDS
</td>
</tr>
<tr>
<td style="text-align:left;">
/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_random_censored_20240802.RDS
</td>
<td style="text-align:left;">
output/de_results_combinedfine_filtered_reharmonize_random_censored_20240802.RDS
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="panel panel-default">
<div class="panel-heading">
<p class="panel-title">
<a data-toggle="collapse" data-parent="#workflowr-checks" href="#strongRepositoryversionstrongNocommitsyet">
<span class="glyphicon glyphicon-ok text-success"
aria-hidden="true"></span> <strong>Repository version:</strong> No
commits yet </a>
</p>
</div>
<div id="strongRepositoryversionstrongNocommitsyet"
class="panel-collapse collapse">
<div class="panel-body">
<p>
Great! You are using Git for version control. Tracking code development
and connecting the code version to the results is critical for
reproducibility.
</p>
<p>
Note that you need to be careful to ensure that all relevant files for
the analysis have been committed to Git prior to generating the results
(you can use <code>wflow_publish</code> or
<code>wflow_git_commit</code>). workflowr only checks the R Markdown
file, but you know if there are other scripts or data files that it
depends on. Below is the status of the Git repository when the results
were generated:
</p>
<pre><code>
Ignored files:
    Ignored:    figure/

Untracked files:
    Untracked:  .DS_Store
    Untracked:  18519_calling.Rmd
    Untracked:  TOM/
    Untracked:  _site.yml
    Untracked:  about.Rmd
    Untracked:  batch_variability.Rmd
    Untracked:  batch_variability.knit.md
    Untracked:  batch_variability.nb.html
    Untracked:  cache/
    Untracked:  cellregmap.Rmd
    Untracked:  celltype.Rmd
    Untracked:  celltype2.Rmd
    Untracked:  celltype2.nb.html
    Untracked:  construct_seurat.Rmd
    Untracked:  construct_seurat2.Rmd
    Untracked:  cormotif_eqtl.Rmd
    Untracked:  de.Rmd
    Untracked:  de2.Rmd
    Untracked:  de2.nb.html
    Untracked:  de_finalized.Rmd
    Untracked:  de_finalized_reharmonized.Rmd
    Untracked:  disease_gene_overlap.Rmd
    Untracked:  disease_gene_overlap_EE.Rmd
    Untracked:  disease_gene_overlap_EE_reharmonized.Rmd
    Untracked:  disease_gene_overlap_EE_reharmonized_fine.Rmd
    Untracked:  disease_gene_overlap_EE_reharmonized_fine_filter10.Rmd
    Untracked:  docs/
    Untracked:  figure1.Rmd
    Untracked:  figure2.Rmd
    Untracked:  figure3.Rmd
    Untracked:  figure4.Rmd
    Untracked:  figures_for_poster.R
    Untracked:  for_yunqi_mash.rmd
    Untracked:  gsea.Rmd
    Untracked:  gsea.nb.html
    Untracked:  gsea_reharmonized.Rmd
    Untracked:  hgwgcna.Rmd
    Untracked:  hgwgcna.nb.html
    Untracked:  hippo_eqtl.Rmd
    Untracked:  index.Rmd
    Untracked:  index_old.Rmd
    Untracked:  license.Rmd
    Untracked:  mash_EE.R
    Untracked:  mash_EE_PC.R
    Untracked:  mash_de.Rmd
    Untracked:  mash_for_peter.r
    Untracked:  matrixEQTL.Rmd
    Untracked:  matrixEQTL.nb.html
    Untracked:  matrixEQTL_reharmonized.Rmd
    Untracked:  ncell_permtesting.R
    Untracked:  plot_eqtl.Rmd
    Untracked:  prep_apex.Rmd
    Untracked:  qtltools.Rmd
    Untracked:  seurat.export.library1.h5Seurat
    Untracked:  shared_functions_style_items.R
    Untracked:  test.rmd
    Untracked:  topics.R
    Untracked:  topics.Rmd
    Untracked:  topics_all.R
    Untracked:  topics_pseudocell.R
    Untracked:  topicsde.R
    Untracked:  voxhunt.Rmd

</code></pre>
<p>
Note that any generated files, e.g. HTML, png, CSS, etc., are not
included in this status report because it is ok for generated content to
have uncommitted changes.
</p>
</div>
</div>
</div>
</div>
<hr>
</div>
<div id="versions" class="tab-pane fade">
<p>
There are no past versions. Publish this analysis with
<code>wflow_publish()</code> to start tracking its development.
</p>
<hr>
</div>
</div>
</div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This page describes steps used to identify differentially expressed
genes from pseudobulk data, classify treatment-responsive cells, plot
cell data from immunostained organoid sections, and generate results
shown in Figure 2, Figure S2, and Figure S3.</p>
<pre class="r"><code>pacman::p_load(edgeR, variancePartition, BiocParallel, limma)
library(Seurat)</code></pre>
<pre><code>Attaching SeuratObject</code></pre>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──</code></pre>
<pre><code>✔ tibble  3.2.1     ✔ dplyr   1.1.4
✔ tidyr   1.3.0     ✔ stringr 1.5.0
✔ readr   2.1.4     ✔ forcats 0.5.1
✔ purrr   1.0.2     </code></pre>
<pre><code>── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()</code></pre>
<pre class="r"><code>library(pals)
library(RColorBrewer)
library(ggbreak)</code></pre>
<pre><code>ggbreak v0.1.2

If you use ggbreak in published research, please cite the following
paper:

S Xu, M Chen, T Feng, L Zhan, L Zhou, G Yu. Use ggbreak to effectively
utilize plotting space to deal with large datasets and outliers.
Frontiers in Genetics. 2021, 12:774846. doi: 10.3389/fgene.2021.774846</code></pre>
<pre class="r"><code>library(mashr)</code></pre>
<pre><code>Loading required package: ashr</code></pre>
<pre class="r"><code>library(udr)
# library(ebnm)
library(pheatmap)
library(ggrepel)
library(knitr)
source(&quot;/project/gilad/umans/tools/R_snippets/mash_missing_pieces.R&quot;)
source(&quot;analysis/shared_functions_style_items.R&quot;)</code></pre>
</div>
<div id="pseudobulk-and-de-analysis" class="section level2">
<h2>Pseudobulk and DE analysis</h2>
<p>Subset data to high quality cells from normoxia, hypoxia, and
hyperoxia conditions.</p>
<pre class="r"><code>harmony.batchandindividual.sct &lt;- readRDS(file = &quot;output/harmony_organoid_dataset.rds&quot;)

subset_seurat &lt;- subset(harmony.batchandindividual.sct, subset = vireo.prob.singlet &gt; 0.95 &amp; nCount_RNA&lt;20000 &amp; nCount_RNA&gt;2500 &amp; treatment != &quot;control21&quot; )</code></pre>
<p>Then, pseudobulk data by individual, collection batch, cell type
(coarse or fine), and treatment condition. For comparison, also create
pseudobulk dataset that ignores cell type.</p>
<pre class="r"><code>pseudo_coarse_quality &lt;- generate.pseudobulk(subset_seurat, labels = c(&quot;combined.annotation.coarse.harmony&quot;, &quot;treatment&quot;, &quot;vireo.individual&quot;, &quot;batch&quot;))

pseudo_fine_quality &lt;- generate.pseudobulk(subset_seurat, labels = c(&quot;combined.annotation.fine.harmony&quot;, &quot;treatment&quot;, &quot;vireo.individual&quot;, &quot;batch&quot;))

pseudo_all_quality &lt;- generate.pseudobulk(subset_seurat, labels = c(&quot;treatment&quot;, &quot;batch&quot;, &quot;vireo.individual&quot;))</code></pre>
<pre class="r"><code>pseudo_fine_quality &lt;- readRDS(file = &quot;output/pseudo_fine_quality_filtered_de_20240305.RDS&quot;)
pseudo_coarse_quality &lt;- readRDS(file = &quot;output/pseudo_coarse_quality_filtered_de_20240305.RDS&quot;)</code></pre>
<p>We previously determined that filtering to a minimum of 20 cells per
pseudobulk sample minimizes excess sample variation associated with cell
numbers.</p>
<pre class="r"><code>pseudo_coarse_quality_de &lt;- filter.pseudobulk(pseudo_coarse_quality, threshold = 20)
pseudo_fine_quality_de &lt;- filter.pseudobulk(pseudo_fine_quality, threshold = 20)</code></pre>
<p>The following function takes pseudobulk input, splits by a chosen
factor (here, cell types), and uses dream to fit a DE model to each
group independently.</p>
<pre class="r"><code>de_genes_pseudoinput &lt;- function(pseudo_input, classification, model_formula, maineffect, min.count = 5,
                                 min.prop=0.7, min.total.count = 10){
  q &lt;- length(base::unique(pseudo_input$meta[[classification]]))
  pseudo &lt;- vector(mode = &quot;list&quot;, length = q)
  names(pseudo) &lt;- unique(pseudo_input$meta[[classification]]) %&gt;% unlist() %&gt;% unname()
  #generate pseudobulk of q+1 clusters
  for (k in names(pseudo)){
    pseudo[[eval(k)]] &lt;- DGEList(pseudo_input$counts[,which(pseudo_input$meta[[classification]]==k)])
    pseudo[[eval(k)]]$samples &lt;- cbind(pseudo[[eval(k)]]$samples[,c(&quot;lib.size&quot;,&quot;norm.factors&quot;)], 
                                       pseudo_input$meta[which(pseudo_input$meta[[classification]]==k ),])
    print(k)
  }
  
  print(&quot;Partitioned pseudobulk data. Initializing results table.&quot;)
  #set up output data structure
  results &lt;- vector(mode = &quot;list&quot;, length = q)
  names(results) &lt;- names(pseudo)
  
  print(&quot;Results list initialized. Beginning DE testing by cluster.&quot;)

#set up DE testing
  for (j in names(pseudo)){
    print(j)
    d &lt;- pseudo[[eval(j)]]
    if(length(base::unique(d$samples[[eval(maineffect)]]))&lt;2){ #prevent testing a cluster that exists in only one condition
      next
    }
    if(length(unique(d$samples[[&quot;batch&quot;]]))&lt;2){ #prevent testing a cluster that exists in only one batch; remove if batch is not in the model
      next
    }
    if(length(unique(d$samples[[&quot;vireo.individual&quot;]]))&lt;3){ #prevent testing a cluster that exists in only one individual; remove if individual is not in the model
      next
    }
   keepgenes &lt;- filterByExpr(d$counts, group = d$samples[[maineffect]])
    print(paste0(&quot;Testing &quot;, sum(keepgenes), &quot; genes&quot;))
    d &lt;- d[keepgenes,]
    d &lt;- calcNormFactors(d, method = &quot;TMM&quot;)
    v &lt;- voomWithDreamWeights(d, model_formula, d$samples, plot=FALSE, BPPARAM = param)
    modelfit &lt;- dream(exprObj = v, formula = model_formula, data = d$samples, quiet = TRUE, suppressWarnings = TRUE, BPPARAM = param) #, L = L
 
    print(paste0(&quot;Tested cluster &quot;, j, &quot; for DE genes&quot;))
    results[[eval(j)]] &lt;- variancePartition::eBayes(modelfit)

    rm(d, keepgenes, v, modelfit)
    print(paste0(&quot;Finished DE testing of cluster &quot;, j))
  }
  return(results)
}</code></pre>
<pre class="r"><code>model_formula &lt;- ~  treatment + (1|batch) + (1|vireo.individual) 
param = SnowParam(20, &quot;SOCK&quot;, progressbar=TRUE)
bpstopOnError(param) &lt;- FALSE
register(param)</code></pre>
<p>First, obtained results for the coarsely-annotated cell types:</p>
<pre class="r"><code>de_results_combinedcoarse_filtered &lt;- de_genes_pseudoinput(pseudo_input = pseudo_coarse_quality_de, classification = &quot;combined.annotation.coarse.harmony&quot;, model_formula = model_formula, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)</code></pre>
<p>Because the VLMC cell type exists, after pseudobulk filtering, in
only one batch, it wasn’t tested above. I can test it separately:</p>
<pre class="r"><code>model_formula_onebatch &lt;- ~  treatment + (1|vireo.individual) 

pseudo_coarse_quality_de_vlmc &lt;- list()
pseudo_coarse_quality_de_vlmc$counts &lt;-  pseudo_coarse_quality_de$counts[,c(which(pseudo_coarse_quality_de$meta$combined.annotation.coarse.harmony==&quot;VLMC&quot;))]
pseudo_coarse_quality_de_vlmc$meta &lt;- pseudo_coarse_quality_de$meta %&gt;% filter(combined.annotation.coarse.harmony == &quot;VLMC&quot;)

de_results_combinedcoarse_filtered_vlmc &lt;- de_genes_pseudoinput(pseudo_input = pseudo_coarse_quality_de_vlmc, classification = &quot;combined.annotation.coarse.harmony&quot;, model_formula = model_formula_onebatch, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)

de_results_combinedcoarse_filtered[[&quot;VLMC&quot;]] &lt;- de_results_combinedcoarse_filtered_vlmc$VLMC

saveRDS(de_results_combinedcoarse_filtered, file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedcoarse_filtered_reharmonize_20240305.RDS&quot;)</code></pre>
<pre class="r"><code>de_results_combinedcoarse_filtered &lt;- readRDS(file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedcoarse_filtered_reharmonize_20240305.RDS&quot;)</code></pre>
<p>Results are given in the supplementary tables:</p>
<pre class="r"><code>hypoxia_coarse &lt;- lapply(names(de_results_combinedcoarse_filtered), function(x) topTable(de_results_combinedcoarse_filtered[[x]], coef = &quot;treatmentstim1pct&quot;, number = Inf))

hypoxia_coarse_table &lt;- gdata::combine(hypoxia_coarse[[1]], hypoxia_coarse[[2]], hypoxia_coarse[[3]], hypoxia_coarse[[4]], hypoxia_coarse[[5]], hypoxia_coarse[[6]], hypoxia_coarse[[7]], hypoxia_coarse[[8]], hypoxia_coarse[[9]], hypoxia_coarse[[10]], names = names(de_results_combinedcoarse_filtered)) 

write_csv(x = hypoxia_coarse_table, file = &quot;output/hypoxia_de_genes_coarse.csv&quot;)

hyperoxia_coarse &lt;- lapply(names(de_results_combinedcoarse_filtered), function(x) topTable(de_results_combinedcoarse_filtered[[x]], coef = &quot;treatmentstim21pct&quot;, number = Inf))

hyperoxia_coarse_table &lt;- gdata::combine(hyperoxia_coarse[[1]], hyperoxia_coarse[[2]], hyperoxia_coarse[[3]], hyperoxia_coarse[[4]], hyperoxia_coarse[[5]], hyperoxia_coarse[[6]], hyperoxia_coarse[[7]], hyperoxia_coarse[[8]], hyperoxia_coarse[[9]], hyperoxia_coarse[[10]], names = names(de_results_combinedcoarse_filtered)) 

write_csv(x = hyperoxia_coarse_table, file = &quot;output/hyperoxia_de_genes_coarse.csv&quot;)</code></pre>
<p>Now I do the same thing for the fine classification. Oligodendrocytes
and midbrain dopaminergic neurons were present in too few individuals
for DE analysis after filtering and for simplicity we can censor them up
front.</p>
<pre class="r"><code>pseudo_fine_quality_de$counts &lt;- pseudo_fine_quality_de$counts[,-c(which(pseudo_fine_quality_de$meta$combined.annotation.fine.harmony==&quot;Oligo&quot;))]
pseudo_fine_quality_de$meta &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;Oligo&quot;)

pseudo_fine_quality_de$counts &lt;- pseudo_fine_quality_de$counts[,-c(which(pseudo_fine_quality_de$meta$combined.annotation.fine.harmony==&quot;MidbrainDA&quot;))]
pseudo_fine_quality_de$meta &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;MidbrainDA&quot;)


de_results_combinedfine_filtered &lt;- de_genes_pseudoinput(pseudo_input = pseudo_fine_quality_de, classification = &quot;combined.annotation.fine.harmony&quot;, model_formula = model_formula, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)</code></pre>
<pre class="r"><code>model_formula_onebatch &lt;- ~  treatment + (1|vireo.individual) 

pseudo_fine_quality_de_vlmc &lt;- list()
pseudo_fine_quality_de_vlmc$counts &lt;-  pseudo_fine_quality_de$counts[,c(which(pseudo_fine_quality_de$meta$combined.annotation.fine.harmony==&quot;VLMC&quot;))]
pseudo_fine_quality_de_vlmc$meta &lt;- pseudo_coarse_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony == &quot;VLMC&quot;)

de_results_combinedfine_filtered_vlmc &lt;- de_genes_pseudoinput(pseudo_input = pseudo_fine_quality_de_vlmc, classification = &quot;combined.annotation.fine.harmony&quot;, model_formula = model_formula_onebatch, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)

de_results_combinedfine_filtered_vlmc[[&quot;VLMC&quot;]] &lt;- de_results_combinedfine_filtered_vlmc$VLMC
saveRDS(de_results_combinedfine_filtered, file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_20240305.RDS&quot;)</code></pre>
<pre class="r"><code>de_results_combinedfine_filtered &lt;- readRDS(file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_20240305.RDS&quot;)</code></pre>
<p>Results are given in the supplementary tables:</p>
<pre class="r"><code>hypoxia_fine &lt;- lapply(names(de_results_combinedfine_filtered), function(x) topTable(de_results_combinedfine_filtered[[x]], coef = &quot;treatmentstim1pct&quot;, number = Inf))
      
hypoxia_fine_table &lt;- gdata::combine(hypoxia_fine[[1]], hypoxia_fine[[2]], hypoxia_fine[[3]], hypoxia_fine[[4]], hypoxia_fine[[5]], hypoxia_fine[[6]], hypoxia_fine[[7]], hypoxia_fine[[8]], hypoxia_fine[[9]], hypoxia_fine[[10]], hypoxia_fine[[11]], hypoxia_fine[[12]], hypoxia_fine[[13]], hypoxia_fine[[14]], hypoxia_fine[[15]], hypoxia_fine[[16]], hypoxia_fine[[17]], hypoxia_fine[[18]], names = names(de_results_combinedfine_filtered)) 

write_csv(x = hypoxia_fine_table, file = &quot;output/hypoxia_de_genes_fine.csv&quot;)

hyperoxia_fine &lt;- lapply(names(de_results_combinedfine_filtered), function(x) topTable(de_results_combinedfine_filtered[[x]], coef = &quot;treatmentstim21pct&quot;, number = Inf))

hyperoxia_fine_table &lt;- gdata::combine(hyperoxia_fine[[1]], hyperoxia_fine[[2]], hyperoxia_fine[[3]], hyperoxia_fine[[4]], hyperoxia_fine[[5]], hyperoxia_fine[[6]], hyperoxia_fine[[7]], hyperoxia_fine[[8]], hyperoxia_fine[[9]], hyperoxia_fine[[10]], hyperoxia_fine[[11]], hyperoxia_fine[[12]], hyperoxia_fine[[13]], hyperoxia_fine[[14]], hyperoxia_fine[[15]], hyperoxia_fine[[16]], hyperoxia_fine[[17]], hyperoxia_fine[[18]], names = names(de_results_combinedfine_filtered)) 

write_csv(x = hyperoxia_fine_table, file = &quot;output/hyperoxia_de_genes_fine.csv&quot;)</code></pre>
<p>Summarize the number of DE genes per cell type, as well as the number
of genes tested.</p>
<pre class="r"><code>de.summary.fine &lt;-  matrix(0, nrow = length(names(de_results_combinedfine_filtered)), ncol =10)
colnames(de.summary.fine) &lt;-c(&quot;hypoxia&quot;, &quot;hyperoxia&quot;, &quot;ncells_hypoxia&quot;, &quot;ncells_hyperoxia&quot;, &quot;nindiv_hypoxia&quot;, &quot;nindiv_hyperoxia&quot;, &quot;hypoxia_mineffect&quot;, &quot;hyperoxia_mineffect&quot;, &quot;hypoxia_testedgenes&quot;, &quot;hyperoxia_testedgenes&quot;)
rownames(de.summary.fine) &lt;- names(de_results_combinedfine_filtered)

for (cell in names(de_results_combinedfine_filtered)){
  de.summary.fine[cell, 1] &lt;- sum(topTable(de_results_combinedfine_filtered[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
  de.summary.fine[cell, 2] &lt;- sum(topTable(de_results_combinedfine_filtered[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
    de.summary.fine[cell, 3] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim1pct&quot;)) %&gt;%  group_by(treatment) %&gt;%  summarize(totals=sum(ncells)) %&gt;% ungroup() %&gt;% summarize(cellnums=mean(totals)) %&gt;% pull(cellnums)
    de.summary.fine[cell, 4] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim21pct&quot;)) %&gt;% group_by(treatment) %&gt;%  summarize(totals=sum(ncells)) %&gt;% ungroup() %&gt;% summarize(cellnums=mean(totals)) %&gt;% pull(cellnums)
    de.summary.fine[cell, 5] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim1pct&quot;)) %&gt;% pull(vireo.individual) %&gt;% unique() %&gt;% length()
    de.summary.fine[cell, 6] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim21pct&quot;)) %&gt;% pull(vireo.individual) %&gt;% unique() %&gt;% length()
    de.summary.fine[cell, 7] &lt;- topTable(de_results_combinedfine_filtered[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow() 
  de.summary.fine[cell, 8] &lt;- (topTable(de_results_combinedfine_filtered[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow())
  de.summary.fine[cell, 9] &lt;- nrow(topTable(de_results_combinedfine_filtered[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf))
  de.summary.fine[cell, 10] &lt;- nrow(topTable(de_results_combinedfine_filtered[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf))

}

de.summary.fine &lt;- de.summary.fine %&gt;% as.data.frame() %&gt;% arrange(nindiv_hypoxia) %&gt;% rownames_to_column(&quot;celltype&quot;)</code></pre>
<p>Plot the fraction of tested genes that are DE (to account for the
differences in number of tested genes between cell types, which results
from different abundances of cell types), along with the fraction that
are DE with greater than 1.5-fold change, and the number of tested
genes.</p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=reorder(celltype, hypoxia/hypoxia_testedgenes), y=hypoxia/hypoxia_testedgenes, fill=celltype)) +  geom_bar(stat = &quot;identity&quot;, alpha=0.5) + ggtitle(&quot;DE summary, fine clusters, hypoxia&quot;)  + theme_light() + 
  geom_bar(aes(y=hypoxia_mineffect/hypoxia_testedgenes), stat = &quot;identity&quot;, alpha=1) +
  ylab(&quot;Fraction of genes differentially expressed&quot;) + 
  guides(x =  guide_axis(angle = 45)) + xlab(&quot;&quot;) + 
  scale_fill_manual(values=manual_palette_fine) + 
  geom_point(aes(x=celltype, y=hypoxia_testedgenes/30000), size=0.8) + 
  geom_line(aes(x=celltype, y=hypoxia_testedgenes/30000, group=1), linewidth=0.3) + 
  theme(legend.position = &quot;none&quot;) + 
    scale_y_continuous(name = &quot;Fraction DE Genes&quot;, sec.axis = sec_axis(~ . *30000, name=&quot;Genes tested&quot;)) </code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-16-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=reorder(celltype, hyperoxia/hyperoxia_testedgenes), y=hyperoxia/hyperoxia_testedgenes, fill=celltype)) +  geom_bar(stat = &quot;identity&quot;, alpha=0.5) + ggtitle(&quot;DE summary, fine clusters, hyperoxia&quot;)  + theme_light() + 
  geom_bar(aes(y=hyperoxia_mineffect/hyperoxia_testedgenes), stat = &quot;identity&quot;, alpha=1) +
  ylab(&quot;Fraction of genes differentially expressed&quot;) + 
  guides(x =  guide_axis(angle = 45)) + xlab(&quot;&quot;) + 
  scale_fill_manual(values=manual_palette_fine) + 
  geom_point(aes(x=celltype, y=hyperoxia_testedgenes/30000), size=0.8) + 
  geom_line(aes(x=celltype, y=hyperoxia_testedgenes/30000, group=1), linewidth=0.3) + 
  theme(legend.position = &quot;none&quot;) + 
    scale_y_continuous(name = &quot;Fraction DE Genes&quot;, sec.axis = sec_axis(~ . *30000, name=&quot;Genes tested&quot;)) </code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-16-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>The number of DE genes after hypoxia, aggregated across cell types,
is given by:</p>
<pre class="r"><code>sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(i) topTable(de_results_combinedfine_filtered[[i]], coef = &quot;treatmentstim1pct&quot;, number = Inf, p.value = 0.05) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 10230</code></pre>
<p>Or, restricting to genes with &gt;1.5-fold change:</p>
<pre class="r"><code>sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(i) topTable(de_results_combinedfine_filtered[[i]], coef = &quot;treatmentstim1pct&quot;, number = Inf, p.value = 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 2703</code></pre>
<p>And after hyperoxia exposure:</p>
<pre class="r"><code>sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(i) topTable(de_results_combinedfine_filtered[[i]], coef = &quot;treatmentstim21pct&quot;, number = Inf, p.value = 0.05) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 10425</code></pre>
<p>Or, restricting to genes with &gt;1.5-fold change:</p>
<pre class="r"><code>sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(i) topTable(de_results_combinedfine_filtered[[i]], coef = &quot;treatmentstim21pct&quot;, number = Inf, p.value = 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 2855</code></pre>
<p>The same summary for coarsely-clustered cells is similar:</p>
<pre class="r"><code>de.summary.coarse &lt;-  matrix(0, nrow = length(names(de_results_combinedcoarse_filtered)), ncol =10)
colnames(de.summary.coarse) &lt;-c(&quot;hypoxia&quot;, &quot;hyperoxia&quot;, &quot;ncells_hypoxia&quot;, &quot;ncells_hyperoxia&quot;, &quot;nindiv_hypoxia&quot;, &quot;nindiv_hyperoxia&quot;, &quot;hypoxia_mineffect&quot;, &quot;hyperoxia_mineffect&quot;, &quot;hypoxia_testedgenes&quot;, &quot;hyperoxia_testedgenes&quot;)
rownames(de.summary.coarse) &lt;- names(de_results_combinedcoarse_filtered)

# here, I&#39;ll count the fraction of tested genes that are DE (hypoxia or hyperoxia) as well as the number of DE genes thresholded to a minimum 1.5-fold change (hypoxia_mineffect or hyperoxia_mineffect).

for (cell in names(de_results_combinedcoarse_filtered)){
  de.summary.coarse[cell, 1] &lt;- sum(topTable(de_results_combinedcoarse_filtered[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
  de.summary.coarse[cell, 2] &lt;- sum(topTable(de_results_combinedcoarse_filtered[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
    de.summary.coarse[cell, 3] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim1pct&quot;)) %&gt;% summarize(total=sum(ncells)) %&gt;% pull(total)
    de.summary.coarse[cell, 4] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim21pct&quot;)) %&gt;% summarize(total=sum(ncells)) %&gt;% pull(total)
    de.summary.coarse[cell, 5] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim1pct&quot;)) %&gt;% pull(vireo.individual) %&gt;% unique() %&gt;% length()
    de.summary.coarse[cell, 6] &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim21pct&quot;)) %&gt;% pull(vireo.individual) %&gt;% unique() %&gt;% length()
    de.summary.coarse[cell, 7] &lt;- (topTable(de_results_combinedcoarse_filtered[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow() )
  de.summary.coarse[cell, 8] &lt;- (topTable(de_results_combinedcoarse_filtered[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow())
  de.summary.coarse[cell, 9] &lt;- topTable(de_results_combinedcoarse_filtered[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf) %&gt;% nrow()
  de.summary.coarse[cell, 10] &lt;- nrow(topTable(de_results_combinedcoarse_filtered[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf))

}

de.summary.coarse &lt;- de.summary.coarse %&gt;% as.data.frame() %&gt;% rownames_to_column(&quot;celltype&quot;)
de.summary.coarse %&gt;% kable(caption = &quot;DE summary Coarse reharmonized clusters&quot;)</code></pre>
<table>
<caption>DE summary Coarse reharmonized clusters</caption>
<colgroup>
<col width="6%" />
<col width="4%" />
<col width="5%" />
<col width="8%" />
<col width="9%" />
<col width="8%" />
<col width="9%" />
<col width="10%" />
<col width="11%" />
<col width="11%" />
<col width="12%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">celltype</th>
<th align="right">hypoxia</th>
<th align="right">hyperoxia</th>
<th align="right">ncells_hypoxia</th>
<th align="right">ncells_hyperoxia</th>
<th align="right">nindiv_hypoxia</th>
<th align="right">nindiv_hyperoxia</th>
<th align="right">hypoxia_mineffect</th>
<th align="right">hyperoxia_mineffect</th>
<th align="right">hypoxia_testedgenes</th>
<th align="right">hyperoxia_testedgenes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Glut</td>
<td align="right">3496</td>
<td align="right">5572</td>
<td align="right">19064</td>
<td align="right">21018</td>
<td align="right">20</td>
<td align="right">19</td>
<td align="right">395</td>
<td align="right">510</td>
<td align="right">15166</td>
<td align="right">15166</td>
</tr>
<tr class="even">
<td align="left">NeuronOther</td>
<td align="right">3673</td>
<td align="right">4655</td>
<td align="right">11252</td>
<td align="right">11098</td>
<td align="right">16</td>
<td align="right">19</td>
<td align="right">372</td>
<td align="right">324</td>
<td align="right">12402</td>
<td align="right">12402</td>
</tr>
<tr class="odd">
<td align="left">IP</td>
<td align="right">4423</td>
<td align="right">5865</td>
<td align="right">6390</td>
<td align="right">6940</td>
<td align="right">19</td>
<td align="right">18</td>
<td align="right">344</td>
<td align="right">420</td>
<td align="right">11462</td>
<td align="right">11462</td>
</tr>
<tr class="even">
<td align="left">RG</td>
<td align="right">6831</td>
<td align="right">7598</td>
<td align="right">16898</td>
<td align="right">15808</td>
<td align="right">21</td>
<td align="right">21</td>
<td align="right">654</td>
<td align="right">548</td>
<td align="right">14749</td>
<td align="right">14749</td>
</tr>
<tr class="odd">
<td align="left">Inh</td>
<td align="right">3292</td>
<td align="right">4870</td>
<td align="right">6187</td>
<td align="right">6441</td>
<td align="right">18</td>
<td align="right">18</td>
<td align="right">280</td>
<td align="right">327</td>
<td align="right">11651</td>
<td align="right">11651</td>
</tr>
<tr class="even">
<td align="left">VLMC</td>
<td align="right">554</td>
<td align="right">1116</td>
<td align="right">1118</td>
<td align="right">1412</td>
<td align="right">6</td>
<td align="right">7</td>
<td align="right">414</td>
<td align="right">571</td>
<td align="right">10171</td>
<td align="right">10171</td>
</tr>
<tr class="odd">
<td align="left">Glia</td>
<td align="right">3546</td>
<td align="right">5123</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">407</td>
<td align="right">454</td>
<td align="right">11900</td>
<td align="right">11900</td>
</tr>
<tr class="even">
<td align="left">Immature</td>
<td align="right">5131</td>
<td align="right">5412</td>
<td align="right">18376</td>
<td align="right">16927</td>
<td align="right">21</td>
<td align="right">20</td>
<td align="right">740</td>
<td align="right">598</td>
<td align="right">12483</td>
<td align="right">12483</td>
</tr>
<tr class="odd">
<td align="left">Choroid</td>
<td align="right">664</td>
<td align="right">980</td>
<td align="right">1424</td>
<td align="right">1461</td>
<td align="right">11</td>
<td align="right">11</td>
<td align="right">396</td>
<td align="right">358</td>
<td align="right">9285</td>
<td align="right">9285</td>
</tr>
<tr class="even">
<td align="left">Cajal</td>
<td align="right">91</td>
<td align="right">275</td>
<td align="right">665</td>
<td align="right">713</td>
<td align="right">6</td>
<td align="right">6</td>
<td align="right">84</td>
<td align="right">198</td>
<td align="right">7687</td>
<td align="right">7687</td>
</tr>
</tbody>
</table>
<p>Plot the fraction of tested genes that are DE (to account for the
differences in number of tested genes between cell types, which results
from different abundances of cell types), along with the fraction that
are DE with greater than 1.5-fold change, and the number of tested
genes.</p>
<pre class="r"><code>ggplot(de.summary.coarse, mapping = aes(x=reorder(celltype, hypoxia/hypoxia_testedgenes), y=hypoxia/hypoxia_testedgenes, fill=celltype)) +  geom_bar(stat = &quot;identity&quot;, alpha=0.5) + ggtitle(&quot;DE summary, fine clusters, hypoxia&quot;)  + theme_light() + 
  geom_bar(aes(y=hypoxia_mineffect/hypoxia_testedgenes), stat = &quot;identity&quot;, alpha=1) +
  ylab(&quot;Fraction of genes differentially expressed&quot;) + 
  guides(x =  guide_axis(angle = 45)) + xlab(&quot;&quot;) + 
  scale_fill_manual(values=manual_palette_fine) + 
  geom_point(aes(x=celltype, y=hypoxia_testedgenes/30000), size=0.8) + 
  geom_line(aes(x=celltype, y=hypoxia_testedgenes/30000, group=1), linewidth=0.3) + 
  theme(legend.position = &quot;none&quot;) + 
    scale_y_continuous(name = &quot;Fraction DE Genes&quot;, sec.axis = sec_axis(~ . *30000, name=&quot;Genes tested&quot;)) </code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-22-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(de.summary.coarse, mapping = aes(x=reorder(celltype, hyperoxia/hyperoxia_testedgenes), y=hyperoxia/hyperoxia_testedgenes, fill=celltype)) +  geom_bar(stat = &quot;identity&quot;, alpha=0.5) + ggtitle(&quot;DE summary, fine clusters, hyperoxia&quot;)  + theme_light() + 
  geom_bar(aes(y=hyperoxia_mineffect/hyperoxia_testedgenes), stat = &quot;identity&quot;, alpha=1) +
  ylab(&quot;Fraction of genes differentially expressed&quot;) + 
  guides(x =  guide_axis(angle = 45)) + xlab(&quot;&quot;) + 
  scale_fill_manual(values=manual_palette_fine) + 
  geom_point(aes(x=celltype, y=hyperoxia_testedgenes/30000), size=0.8) + 
  geom_line(aes(x=celltype, y=hyperoxia_testedgenes/30000, group=1), linewidth=0.3) + 
  theme(legend.position = &quot;none&quot;) + 
    scale_y_continuous(name = &quot;Fraction DE Genes&quot;, sec.axis = sec_axis(~ . *30000, name=&quot;Genes tested&quot;)) </code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-22-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>The number of hypoxia DE genes aggregated across cell types is given
by:</p>
<pre class="r"><code>sapply(c(&quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;Glia&quot;, &quot;Immature&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;VLMC&quot;), function(i) topTable(de_results_combinedcoarse_filtered[[i]], coef = &quot;treatmentstim1pct&quot;, number = Inf, p.value = 0.05)  %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 10578</code></pre>
<p>Or, restricting to &gt;1.5-fold change:</p>
<pre class="r"><code>sapply(c(&quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;Glia&quot;, &quot;Immature&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;VLMC&quot;), function(i) topTable(de_results_combinedcoarse_filtered[[i]], coef = &quot;treatmentstim1pct&quot;, number = Inf, p.value = 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 2120</code></pre>
<p>For hyperoxia, this is given by: The number of hypoxia DE genes
aggregated across cell types is given by:</p>
<pre class="r"><code>sapply(c(&quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;Glia&quot;, &quot;Immature&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;VLMC&quot;), function(i) topTable(de_results_combinedcoarse_filtered[[i]], coef = &quot;treatmentstim21pct&quot;, number = Inf, p.value = 0.05)  %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 10700</code></pre>
<p>Or, restricting to &gt;1.5-fold change:</p>
<pre class="r"><code>sapply(c(&quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;Glia&quot;, &quot;Immature&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;VLMC&quot;), function(i) topTable(de_results_combinedcoarse_filtered[[i]], coef = &quot;treatmentstim21pct&quot;, number = Inf, p.value = 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% pull(gene)) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 2097</code></pre>
<p>Ignoring cell type information yields a different number of DE
genes:</p>
<pre class="r"><code>results_all &lt;- readRDS(file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_pseudoall_filtered_20231107.RDS&quot;)

sum(topTable(results_all, coef=&quot;treatmentstim1pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)</code></pre>
<pre><code>[1] 8611</code></pre>
<pre class="r"><code>sum(topTable(results_all, coef=&quot;treatmentstim21pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)</code></pre>
<pre><code>[1] 10509</code></pre>
<p>If we restrict this to genes with &gt;1.5fold change in
expression:</p>
<pre class="r"><code>topTable(results_all, coef=&quot;treatmentstim1pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow()</code></pre>
<pre><code>[1] 815</code></pre>
<pre class="r"><code>topTable(results_all, coef=&quot;treatmentstim21pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow()</code></pre>
<pre><code>[1] 948</code></pre>
<p>There is a relationship between the number of DE genes and the number
of cells (or, equivalently, individuals) tested, but that’s not a
complete explanation. Instead, it seems to have a larger impact for
detecting small effect sizes:</p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=ncells_hypoxia, y=hypoxia, label=celltype)) + 
  geom_point(aes(size=nindiv_hypoxia, color=celltype)) + 
  geom_text_repel() + 
  ggtitle(&quot;DE summary fine clusters, hypoxia&quot;) +  
  # geom_smooth(method = &quot;lm&quot;, se = FALSE, color=&quot;black&quot;, lty=2) + 
  theme_light() +
  scale_color_manual(values=manual_palette_fine) +
  theme(legend.position=&quot;none&quot;) + scale_x_log10() +
  xlab(&quot;Number of cells in comparison&quot;) +
  ylab(&quot;Number of DE genes&quot;)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-29-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=nindiv_hypoxia, y=hypoxia, label=celltype)) + 
  geom_point(aes(size=nindiv_hypoxia, color=celltype)) + 
  geom_text_repel() + 
  ggtitle(&quot;DE summary fine clusters, hypoxia&quot;) +  
  # geom_smooth(method = &quot;lm&quot;, se = FALSE, color=&quot;black&quot;, lty=2) + 
  theme_light() +
  scale_color_manual(values=manual_palette_fine) +
  theme(legend.position=&quot;none&quot;) + 
  xlab(&quot;Number of individuals in comparison&quot;) +
  ylab(&quot;Number of DE genes&quot;)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-29-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=nindiv_hypoxia, y=hypoxia/hypoxia_testedgenes, label=celltype)) + 
  geom_point(aes(size=nindiv_hypoxia, color=celltype)) + 
  geom_text_repel() + 
  ggtitle(&quot;DE summary fine clusters, hypoxia&quot;) +  
  # geom_smooth(method = &quot;lm&quot;, se = FALSE, color=&quot;black&quot;, lty=2) + 
  theme_light() +
  scale_color_manual(values=manual_palette_fine) +
  theme(legend.position=&quot;none&quot;) + 
  xlab(&quot;Number of individuals in comparison&quot;) +
  ylab(&quot;Fraction of genes DE&quot;)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-29-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=nindiv_hypoxia, y=hypoxia_mineffect, label=celltype)) + 
  geom_point(aes(size=nindiv_hypoxia, color=celltype)) + 
  geom_text_repel() + 
  ggtitle(&quot;DE summary fine clusters, hypoxia, &gt;1.5fold effect size&quot;) +  
  # geom_smooth(method = &quot;lm&quot;, se = FALSE, color=&quot;black&quot;, lty=2, lwd=0.5) + 
  theme_light() +
  scale_color_manual(values=manual_palette_fine) +
  theme(legend.position=&quot;none&quot;) + 
  xlab(&quot;Number of individuals in comparison&quot;) +
  ylab(&quot;Number of DE genes&quot;)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-29-4.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(de.summary.fine, mapping = aes(x=nindiv_hypoxia, y=hypoxia_mineffect/hypoxia_testedgenes, label=celltype)) + 
  geom_point(aes(size=nindiv_hypoxia, color=celltype)) + 
  geom_text_repel() + 
  ggtitle(&quot;DE summary fine clusters, hypoxia, &gt;1.5fold effect size&quot;) +  
  # geom_smooth(method = &quot;lm&quot;, se = FALSE, color=&quot;black&quot;, lty=2, lwd=0.5) + 
  theme_light() +
  scale_color_manual(values=manual_palette_fine) +
  theme(legend.position=&quot;none&quot;) + 
  xlab(&quot;Number of individuals in comparison&quot;) +
  ylab(&quot;Fraction of genes DE&quot;)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-29-5.png" width="672" style="display: block; margin: auto;" /></p>
<p>Number of individuals, rather than number of cells per pseudobulk
sample, is the important factor contributing to power here. We
separately found that including cell numbers as a covariation in the DE
model has no effect on the relationship shown above, nor do differences
in transcriptome size between cell types (constraining all comparisons
to a common transcriptome preserved this relationship).</p>
</div>
<div id="mash-for-de-results" class="section level2">
<h2>mash for DE results</h2>
<p>Because of differential power between cell types, we run the risk of
underestimating how many DE effects are shared between different cell
types or conditions. Here, I use <a
href="https://stephenslab.github.io/mashr/index.html">mash</a> to
estimate posterior effect sizes and significance metrics.</p>
<pre class="r"><code>library(mashr)
library(udr)
library(flashier)</code></pre>
<pre><code>Loading required package: ebnm</code></pre>
<pre><code>Loading required package: magrittr</code></pre>
<pre><code>
Attaching package: &#39;magrittr&#39;</code></pre>
<pre><code>The following object is masked from &#39;package:purrr&#39;:

    set_names</code></pre>
<pre><code>The following object is masked from &#39;package:tidyr&#39;:

    extract</code></pre>
<pre><code>Registered S3 methods overwritten by &#39;flashier&#39;:
  method      from  
  plot.flash  flashr
  print.flash flashr</code></pre>
<pre><code>
Attaching package: &#39;flashier&#39;</code></pre>
<pre><code>The following objects are masked from &#39;package:flashr&#39;:

    flash, flash_backfit</code></pre>
<pre class="r"><code>## Function to estimate residual covariance for udr
estimate_null_cov_simple = function(data, z_thresh=2, est_cor = TRUE){
  z = data$Bhat/data$Shat
  max_absz = apply(abs(z),1, max)
  nullish = which(max_absz &lt; z_thresh)
  # the null-z vs. number of conditions.
  if(length(nullish)&lt;ncol(z)){
    stop(&quot;not enough null data to estimate null correlation&quot;)
  }
  nullish_Bhat= data$Bhat[nullish,]
  Vhat = cov(nullish_Bhat)
  if(est_cor){
    Vhat = cov2cor(Vhat)
  }
  return(Vhat)
}</code></pre>
<p>First, repeat the DE above, omitting
<code>variancePartition::eBayes(modelfit)</code>, as this shrinkage will
be done by mash.</p>
<pre class="r"><code>de_genes_pseudoinput_for_mash &lt;- function(pseudo_input, classification, model_formula, maineffect, min.count = 5,
                                 min.prop=0.7, min.total.count = 10){
  q &lt;- length(base::unique(pseudo_input$meta[[classification]]))
  pseudo &lt;- vector(mode = &quot;list&quot;, length = q)
  names(pseudo) &lt;- unique(pseudo_input$meta[[classification]]) %&gt;% unlist() %&gt;% unname()
  #generate pseudobulk of q+1 clusters
  for (k in names(pseudo)){
    pseudo[[eval(k)]] &lt;- DGEList(pseudo_input$counts[,which(pseudo_input$meta[[classification]]==k)])
    pseudo[[eval(k)]]$samples &lt;- cbind(pseudo[[eval(k)]]$samples[,c(&quot;lib.size&quot;,&quot;norm.factors&quot;)], 
                                       pseudo_input$meta[which(pseudo_input$meta[[classification]]==k ),])
    print(k)
  }
  
  print(&quot;Partitioned pseudobulk data. Initializing results table.&quot;)
  #set up output data structure
  results &lt;- vector(mode = &quot;list&quot;, length = q)
  names(results) &lt;- names(pseudo)
  
  print(&quot;Results list initialized. Beginning DE testing by cluster.&quot;)

#set up DE testing
  for (j in names(pseudo)){
    print(j)
    d &lt;- pseudo[[eval(j)]]
    if(length(base::unique(d$samples[[eval(maineffect)]]))&lt;2){ #prevent testing a cluster that exists in only one condition
      next
    }
    if(length(unique(d$samples[[&quot;batch&quot;]]))&lt;2){ #prevent testing a cluster that exists in only one batch; remove if batch is not in the model
      next
    }
    if(length(unique(d$samples[[&quot;vireo.individual&quot;]]))&lt;3){ #prevent testing a cluster that exists in only one individual; remove if individual is not in the model
      next
    }
   keepgenes &lt;- filterByExpr(d$counts, group = d$samples[[maineffect]])
    print(paste0(&quot;Testing &quot;, sum(keepgenes), &quot; genes&quot;))
    d &lt;- d[keepgenes,]
    d &lt;- calcNormFactors(d, method = &quot;TMM&quot;)
    v &lt;- voomWithDreamWeights(d, model_formula, d$samples, plot=FALSE, BPPARAM = param)
    modelfit &lt;- dream(exprObj = v, formula = model_formula, data = d$samples, quiet = TRUE, suppressWarnings = TRUE, BPPARAM = param) #, L = L
 
    print(paste0(&quot;Tested cluster &quot;, j, &quot; for DE genes&quot;))
    results[[eval(j)]] &lt;- modelfit

    rm(d, keepgenes, v, modelfit)
    print(paste0(&quot;Finished DE testing of cluster &quot;, j))
  }
  return(results)
}</code></pre>
<pre class="r"><code>model_formula &lt;- ~  treatment + (1|batch) + (1|vireo.individual) 
param = SnowParam(20, &quot;SOCK&quot;, progressbar=TRUE)
bpstopOnError(param) &lt;- FALSE
register(param)</code></pre>
<pre class="r"><code>pseudo_fine_quality_de$counts &lt;- pseudo_fine_quality_de$counts[,-c(which(pseudo_fine_quality_de$meta$combined.annotation.fine.harmony==&quot;Oligo&quot;))]
pseudo_fine_quality_de$meta &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;Oligo&quot;)

pseudo_fine_quality_de$counts &lt;- pseudo_fine_quality_de$counts[,-c(which(pseudo_fine_quality_de$meta$combined.annotation.fine.harmony==&quot;MidbrainDA&quot;))]
pseudo_fine_quality_de$meta &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;MidbrainDA&quot;)

de_results_combinedfine_filtered_mash &lt;- de_genes_pseudoinput_for_mash(pseudo_input = pseudo_fine_quality_de, classification = &quot;combined.annotation.fine.harmony&quot;, model_formula = model_formula, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)</code></pre>
<pre class="r"><code>model_formula_onebatch &lt;- ~  treatment + (1|vireo.individual) 

pseudo_fine_quality_de_vlmc &lt;- list()
pseudo_fine_quality_de_vlmc$counts &lt;-  pseudo_fine_quality_de$counts[,c(which(pseudo_fine_quality_de$meta$combined.annotation.fine.harmony==&quot;VLMC&quot;))]
pseudo_fine_quality_de_vlmc$meta &lt;- pseudo_fine_quality_de$meta %&gt;% filter(combined.annotation.fine.harmony == &quot;VLMC&quot;)

de_results_combinedfine_filtered_vlmc &lt;- de_genes_pseudoinput_for_mash(pseudo_input = pseudo_fine_quality_de_vlmc, classification = &quot;combined.annotation.fine.harmony&quot;, model_formula = model_formula_onebatch, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)

de_results_combinedfine_filtered_mash[[&quot;VLMC&quot;]] &lt;- de_results_combinedfine_filtered_vlmc$VLMC

saveRDS(de_results_combinedfine_filtered_mash, file =  &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_for_mash_20240731.RDS&quot;)</code></pre>
<pre class="r"><code>res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Glut1=logFC) 

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, RG1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, IP1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Immature1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, NeuronOther1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, VLMC1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Choroid1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Cajal1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Inh1=logFC) %&gt;% full_join(res)

##
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;CorticalHem&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, CorticalHem1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GliaProg&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, GliaProg1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GlutNTS&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, GlutNTS1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IPcycling&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, IPcycling1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhGNRH&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhGNRH1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhMidbrain&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhMidbrain1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhSST&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhSST1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhThalamic&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhThalamic1=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RGcycling&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, RGcycling1=logFC) %&gt;% full_join(res)

##
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Glut21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, RG21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, IP21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Immature21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, NeuronOther21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, VLMC21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Choroid21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Cajal21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Inh21=logFC) %&gt;% full_join(res)
##
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;CorticalHem&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, CorticalHem21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GliaProg&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, GliaProg21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GlutNTS&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, GlutNTS21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IPcycling&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, IPcycling21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhGNRH&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhGNRH21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhMidbrain&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhMidbrain21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhSST&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhSST21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhThalamic&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, InhThalamic21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RGcycling&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, RGcycling21=logFC) %&gt;% full_join(res)

mash_de_effect &lt;- res %&gt;%  `rownames&lt;-` (.$gene) %&gt;% dplyr::select(-gene)

# And the standard errors

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Glut1=logFC/t) %&gt;%  dplyr::select(gene, Glut1) 

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(RG1=logFC/t) %&gt;%  dplyr::select(gene, RG1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(IP1=logFC/t) %&gt;%  dplyr::select(gene, IP1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Immature1=logFC/t) %&gt;%  dplyr::select(gene, Immature1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(NeuronOther1=logFC/t) %&gt;%   dplyr::select(gene, NeuronOther1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(VLMC1=logFC/t) %&gt;%  dplyr::select(gene, VLMC1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Choroid1=logFC/t) %&gt;%  dplyr::select(gene, Choroid1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Cajal1=logFC/t) %&gt;%  dplyr::select(gene, Cajal1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Inh1=logFC/t) %&gt;%  dplyr::select(gene, Inh1) %&gt;% full_join(se)
##
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;CorticalHem&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  mutate(CorticalHem1=logFC/t) %&gt;%  dplyr::select(gene, CorticalHem1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GliaProg&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;)%&gt;% mutate(GliaProg1=logFC/t) %&gt;%  dplyr::select(gene, GliaProg1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GlutNTS&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(GlutNTS1=logFC/t) %&gt;%  dplyr::select(gene, GlutNTS1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IPcycling&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(IPcycling1=logFC/t) %&gt;%  dplyr::select(gene, IPcycling1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhGNRH&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhGNRH1=logFC/t) %&gt;%  dplyr::select(gene, InhGNRH1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhMidbrain&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhMidbrain1=logFC/t) %&gt;%  dplyr::select(gene, InhMidbrain1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhSST&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhSST1=logFC/t) %&gt;%  dplyr::select(gene, InhSST1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhThalamic&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhThalamic1=logFC/t) %&gt;%  dplyr::select(gene, InhThalamic1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RGcycling&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(RGcycling1=logFC/t) %&gt;%  dplyr::select(gene, RGcycling1) %&gt;% full_join(se)


se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Glut21=logFC/t) %&gt;%  dplyr::select(gene, Glut21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(RG21=logFC/t) %&gt;%  dplyr::select(gene, RG21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(IP21=logFC/t) %&gt;%  dplyr::select(gene, IP21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Immature21=logFC/t) %&gt;%  dplyr::select(gene, Immature21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(NeuronOther21=logFC/t) %&gt;%   dplyr::select(gene, NeuronOther21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(VLMC21=logFC/t) %&gt;%  dplyr::select(gene, VLMC21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Choroid21=logFC/t) %&gt;%  dplyr::select(gene, Choroid21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Cajal21=logFC/t) %&gt;%  dplyr::select(gene, Cajal21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Inh21=logFC/t) %&gt;%  dplyr::select(gene, Inh21) %&gt;% full_join(se)
##
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;CorticalHem&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  mutate(CorticalHem21=logFC/t) %&gt;%  dplyr::select(gene, CorticalHem21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GliaProg&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;)%&gt;% mutate(GliaProg21=logFC/t) %&gt;%  dplyr::select(gene, GliaProg21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;GlutNTS&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(GlutNTS21=logFC/t) %&gt;%  dplyr::select(gene, GlutNTS21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;IPcycling&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(IPcycling21=logFC/t) %&gt;%  dplyr::select(gene, IPcycling21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhGNRH&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhGNRH21=logFC/t) %&gt;%  dplyr::select(gene, InhGNRH21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhMidbrain&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhMidbrain21=logFC/t) %&gt;%  dplyr::select(gene, InhMidbrain21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhSST&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhSST21=logFC/t) %&gt;%  dplyr::select(gene, InhSST21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;InhThalamic&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(InhThalamic21=logFC/t) %&gt;%  dplyr::select(gene, InhThalamic21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedfine_filtered_mash[[&quot;RGcycling&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(RGcycling21=logFC/t) %&gt;%  dplyr::select(gene, RGcycling21) %&gt;% full_join(se)
##

mash_de_se &lt;- se %&gt;%  `rownames&lt;-` (.$gene) %&gt;% dplyr::select(-gene)

mash_dataset9 &lt;- mash_set_data(as.matrix(mash_de_effect), as.matrix(mash_de_se), alpha = 1)
#set up cov matrix
##select strong signals
m.1by1 &lt;- mash_1by1(mash_dataset9)
strong &lt;- get_significant_results(m.1by1, 0.01)

#account for correlations
V.simple = estimate_null_correlation_simple(mash_dataset9, z_thresh = 3)
data.Vsimple = mash_update_data(mash_dataset9, V=V.simple)

dat.strong = list(data.Vsimple$Bhat[strong, ], data.Vsimple$Shat[strong, ])
names(dat.strong) = c(&quot;Bhat&quot;, &quot;Shat&quot;)
dat.random = list(data.Vsimple$Bhat[-strong, ], data.Vsimple$Shat[-strong, ])
names(dat.random) = c(&quot;Bhat&quot;, &quot;Shat&quot;)

#cannonical covariance using all the tests
U.c = cov_canonical(data.Vsimple) 
#data-driven covariance using flashr + pca
U.f = cov_flash(data.Vsimple, subset = strong)
U.pca = cov_pca(data.Vsimple,ifelse(ncol(mash_de_effect)&lt;5, ncol(mash_de_effect), 5),subset=strong)

# Denoised data-driven matrices
# Initialization of udr 
maxiter=1e3
U.init = c(U.f, U.pca)
Vhat = estimate_null_cov_simple(dat.random, est_cor = FALSE)
fit0 &lt;- ud_init(dat.strong$Bhat, U_scaled = U.c, n_rank1 = 0, U_unconstrained = U.init, V = Vhat)

# fit udr model
fit1 &lt;- ud_fit(fit0, control = list(unconstrained.update = &quot;ted&quot;, maxiter = maxiter, tol = 1e-2, tol.lik = 1e-2))

# extract data-driven covariance from udr model. (A list of covariance matrices)
U.ted &lt;- lapply(fit1$U,function (e) &quot;[[&quot;(e,&quot;mat&quot;))

#fit mash model to all the tests
m.Vsimple = mash(data.Vsimple, c(U.c, U.ted)) 
#compute posterior stat
m_posterior &lt;- mash_compute_posterior_matrices(m.Vsimple, data.Vsimple)
saveRDS(m.Vsimple, file=&quot;output/mash_de/mashmodel_dataset9_fine_reharmonized_z3.RDS&quot;)
saveRDS(m_posterior, file=&quot;output/mash_de/mashposterior_dataset9_fine_reharmonized_z3.RDS&quot;)</code></pre>
<p>Using these posterior results, I define “shared” effects between any
two conditions as those that are (a) significant in at least one of the
conditions and (b) differ in magnitude by less than a factor of 2.5,
with the same sign.</p>
<p>The matrix of sharing by these criteria is obtained from:</p>
<pre class="r"><code>m_posterior &lt;- readRDS(file=&quot;output/mash_de/mashposterior_dataset9_fine_reharmonized_z3.RDS&quot;)

shared.size = matrix(NA,nrow = ncol(m_posterior$lfsr),ncol=ncol(m_posterior$lfsr))
colnames(shared.size) &lt;- rownames(shared.size) &lt;-colnames(m_posterior$lfsr)
for (i in 1:ncol(m_posterior$lfsr)) {
  for (j in 1:ncol(m_posterior$lfsr)) {
    sig.row=which(m_posterior$lfsr[,i] &lt; 0.05)
    sig.col=which(m_posterior$lfsr[,j] &lt; 0.05)
    a=(union(sig.row,sig.col)) # at least one effect is significant
    quotient=(m_posterior$PosteriorMean[a,i]/m_posterior$PosteriorMean[a,j])
    shared.size[i,j] = mean(quotient &gt; 0.4 &amp; quotient &lt; 2.5)
  }
}

# alternatively, additionally constrain to a minimum logFC
shared.size.constrained = matrix(NA,nrow = ncol(m_posterior$lfsr),ncol=ncol(m_posterior$lfsr))
colnames(shared.size.constrained) &lt;- rownames(shared.size.constrained) &lt;-colnames(m_posterior$lfsr)
for (i in 1:ncol(m_posterior$lfsr)) {
  for (j in 1:ncol(m_posterior$lfsr)) {
    sig.row=which(m_posterior$lfsr[,i] &lt; 0.05)
    sig.col=which(m_posterior$lfsr[,j] &lt; 0.05)
    size.row=which(abs(m_posterior$PosteriorMean[,i]) &gt; 0.58)
    size.col=which(abs(m_posterior$PosteriorMean[,j]) &gt; 0.58)
    a=intersect(union(sig.row,sig.col), union(size.row, size.col)) # at least one effect is significant
    # constrain to those with at least one posterior mean logFC&gt;0.58
    quotient=(m_posterior$PosteriorMean[a,i]/m_posterior$PosteriorMean[a,j])
    shared.size.constrained[i,j] = mean(quotient &gt; 0.4 &amp; quotient &lt; 2.5 )
  }
}


# reorder the rows and columns for consistent display

shared.size &lt;- shared.size[c( &quot;InhMidbrain21&quot;, &quot;InhThalamic21&quot;, &quot;InhGNRH21&quot;, &quot;InhSST21&quot;,   &quot;Inh21&quot;, &quot;IPcycling21&quot;, &quot;IP21&quot;,  &quot;RGcycling21&quot;, &quot;RG21&quot;,  &quot;CorticalHem21&quot;, &quot;GliaProg21&quot;,   &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;GlutNTS21&quot;, &quot;InhMidbrain1&quot;, &quot;InhThalamic1&quot;, &quot;InhGNRH1&quot;, &quot;InhSST1&quot;,   &quot;Inh1&quot;,  &quot;IPcycling1&quot;, &quot;IP1&quot;,  &quot;RGcycling1&quot;, &quot;RG1&quot;,  &quot;CorticalHem1&quot;, &quot;GliaProg1&quot;,  &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;, &quot;GlutNTS1&quot;),  
                          c( &quot;InhMidbrain21&quot;, &quot;InhThalamic21&quot;, &quot;InhGNRH21&quot;, &quot;InhSST21&quot;,   &quot;Inh21&quot;, &quot;IPcycling21&quot;, &quot;IP21&quot;,  &quot;RGcycling21&quot;, &quot;RG21&quot;,  &quot;CorticalHem21&quot;, &quot;GliaProg21&quot;,   &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;GlutNTS21&quot;, &quot;InhMidbrain1&quot;, &quot;InhThalamic1&quot;, &quot;InhGNRH1&quot;, &quot;InhSST1&quot;,   &quot;Inh1&quot;,  &quot;IPcycling1&quot;, &quot;IP1&quot;,  &quot;RGcycling1&quot;, &quot;RG1&quot;,  &quot;CorticalHem1&quot;, &quot;GliaProg1&quot;,  &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;, &quot;GlutNTS1&quot;)]

shared.size.constrained &lt;- shared.size.constrained[c( &quot;InhMidbrain21&quot;, &quot;InhThalamic21&quot;, &quot;InhGNRH21&quot;, &quot;InhSST21&quot;,   &quot;Inh21&quot;, &quot;IPcycling21&quot;, &quot;IP21&quot;,  &quot;RGcycling21&quot;, &quot;RG21&quot;,  &quot;CorticalHem21&quot;, &quot;GliaProg21&quot;,   &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;GlutNTS21&quot;, &quot;InhMidbrain1&quot;, &quot;InhThalamic1&quot;, &quot;InhGNRH1&quot;, &quot;InhSST1&quot;,   &quot;Inh1&quot;,  &quot;IPcycling1&quot;, &quot;IP1&quot;,  &quot;RGcycling1&quot;, &quot;RG1&quot;,  &quot;CorticalHem1&quot;, &quot;GliaProg1&quot;,  &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;, &quot;GlutNTS1&quot;),  
                          c( &quot;InhMidbrain21&quot;, &quot;InhThalamic21&quot;, &quot;InhGNRH21&quot;, &quot;InhSST21&quot;,   &quot;Inh21&quot;, &quot;IPcycling21&quot;, &quot;IP21&quot;,  &quot;RGcycling21&quot;, &quot;RG21&quot;,  &quot;CorticalHem21&quot;, &quot;GliaProg21&quot;,   &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;GlutNTS21&quot;, &quot;InhMidbrain1&quot;, &quot;InhThalamic1&quot;, &quot;InhGNRH1&quot;, &quot;InhSST1&quot;,   &quot;Inh1&quot;,  &quot;IPcycling1&quot;, &quot;IP1&quot;,  &quot;RGcycling1&quot;, &quot;RG1&quot;,  &quot;CorticalHem1&quot;, &quot;GliaProg1&quot;,  &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;, &quot;GlutNTS1&quot;)]



# intersection instead of union
shared.size.intersection = matrix(NA,nrow = ncol(m_posterior$lfsr),ncol=ncol(m_posterior$lfsr))
colnames(shared.size.intersection) &lt;- rownames(shared.size.intersection) &lt;-colnames(m_posterior$lfsr)
for (i in 1:ncol(m_posterior$lfsr)) {
  for (j in 1:ncol(m_posterior$lfsr)) {
    sig.row=which(m_posterior$lfsr[,i] &lt; 0.05)
    sig.col=which(m_posterior$lfsr[,j] &lt; 0.05)
    a=(intersect(sig.row,sig.col)) # at least one effect is significant
    quotient=(m_posterior$PosteriorMean[a,i]/m_posterior$PosteriorMean[a,j])
    shared.size.intersection[i,j] = mean(quotient &gt; 0.4 &amp; quotient &lt; 2.5)
  }
}

# alternatively, constrain to a minimum logFC;
# use intersect instead of union
shared.size.constrained.intersection = matrix(NA,nrow = ncol(m_posterior$lfsr),ncol=ncol(m_posterior$lfsr))
colnames(shared.size.constrained.intersection) &lt;- rownames(shared.size.constrained.intersection) &lt;-colnames(m_posterior$lfsr)
for (i in 1:ncol(m_posterior$lfsr)) {
  for (j in 1:ncol(m_posterior$lfsr)) {
    sig.row=which(m_posterior$lfsr[,i] &lt; 0.05)
    sig.col=which(m_posterior$lfsr[,j] &lt; 0.05)
    size.row=which(abs(m_posterior$PosteriorMean[,i]) &gt; 0.58)
    size.col=which(abs(m_posterior$PosteriorMean[,j]) &gt; 0.58)
    a=intersect(intersect(sig.row,sig.col), union(size.row, size.col)) # at least one effect is significant
    # constrain to those with at least one posterior mean logFC&gt;0.58
    quotient=(m_posterior$PosteriorMean[a,i]/m_posterior$PosteriorMean[a,j])
    shared.size.constrained.intersection[i,j] = mean(quotient &gt; 0.4 &amp; quotient &lt; 2.5 )
  }
}</code></pre>
<p>Plot the fraction of effects that are shared as a heatmap:</p>
<pre class="r"><code>labels &lt;- data.frame(celltype=str_extract(rownames(shared.size), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(rownames(shared.size), pattern = &quot;[:digit:]+&quot;))
rownames(labels) &lt;- rownames(shared.size)

celltypeCol &lt;- manual_palette_fine

treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
# names(celltypeCol) &lt;- unique(labels$celltype)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

# now use pheatmap to annotate
pheatmap(shared.size, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(50),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_row = labels,
         annotation_colors = annoCol, cluster_rows = FALSE, cluster_cols = FALSE
         )</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-36-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code># for logFC-constrained
labels &lt;- data.frame(celltype=str_extract(rownames(shared.size.constrained), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(rownames(shared.size.constrained), pattern = &quot;[:digit:]+&quot;))
rownames(labels) &lt;- rownames(shared.size.constrained)

# make a color palette for each of the levels of the labels
celltypeCol &lt;- manual_palette_fine
treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

pheatmap(shared.size.constrained, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(50),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_row = labels,
         annotation_colors = annoCol, cluster_rows = FALSE, cluster_cols = FALSE
         )</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-36-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>labels &lt;- data.frame(celltype=str_extract(rownames(shared.size.intersection), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(rownames(shared.size.intersection), pattern = &quot;[:digit:]+&quot;))
rownames(labels) &lt;- rownames(shared.size.intersection)

celltypeCol &lt;- manual_palette_fine

treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
# names(celltypeCol) &lt;- unique(labels$celltype)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

# now use pheatmap to annotate
pheatmap(shared.size.intersection, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(50),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_row = labels,
         annotation_colors = annoCol, cluster_rows = FALSE, cluster_cols = FALSE
         )</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-37-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code># for logFC-constrained
labels &lt;- data.frame(celltype=str_extract(rownames(shared.size.constrained.intersection), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(rownames(shared.size.constrained.intersection), pattern = &quot;[:digit:]+&quot;))
rownames(labels) &lt;- rownames(shared.size.constrained.intersection)

# make a color palette for each of the levels of the labels
celltypeCol &lt;- manual_palette_fine
treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

pheatmap(shared.size.constrained.intersection, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(50),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_row = labels,
         annotation_colors = annoCol, cluster_rows = FALSE, cluster_cols = FALSE
         )</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-37-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>How many genes are DE in at least one cell type (FDR&lt;0.05, effect
size&gt;1.5-fold) after mash?</p>
<pre class="r"><code>sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(cell) names(which(abs(m_posterior$PosteriorMean[which(m_posterior$lfsr[,paste0(cell, &quot;1&quot;)] &lt; 0.05), paste0(cell, &quot;1&quot;)])&gt;0.58))) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 2820</code></pre>
<p>after hypoxia, and</p>
<pre class="r"><code>sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(cell) names(which(abs(m_posterior$PosteriorMean[which(m_posterior$lfsr[,paste0(cell, &quot;21&quot;)] &lt; 0.05), paste0(cell, &quot;21&quot;)])&gt;0.58))) %&gt;% unlist() %&gt;% unname() %&gt;% unique() %&gt;% length()</code></pre>
<pre><code>[1] 3832</code></pre>
<p>after hyperoxia. This represents a modest increase in detection for
the hypoxia condition, and a substantial increase for hyperoxia</p>
<p>We can also ask how many are DE in K or fewer cell types</p>
<pre class="r"><code>map_dfr(1:18, function(x) sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(cell) names(which(abs(m_posterior$PosteriorMean[which(m_posterior$lfsr[,paste0(cell, &quot;1&quot;)] &lt; 0.05), paste0(cell, &quot;1&quot;)])&gt;0.58))) %&gt;%
  unlist() %&gt;% 
  unname() %&gt;% 
  table() %&gt;% as.data.frame() %&gt;% summarize(sum(Freq&lt;=x))) %&gt;% mutate(x=1:18)</code></pre>
<pre><code>   sum(Freq &lt;= x)  x
1            1190  1
2            1674  2
3            1930  3
4            2151  4
5            2294  5
6            2401  6
7            2484  7
8            2523  8
9            2577  9
10           2614 10
11           2656 11
12           2690 12
13           2715 13
14           2729 14
15           2747 15
16           2763 16
17           2791 17
18           2820 18</code></pre>
<pre class="r"><code>map_dfr(1:18, function(x) sapply(c(&quot;GlutNTS&quot;, &quot;Glut&quot;, &quot;NeuronOther&quot; ,&quot;IP&quot; ,&quot;RG&quot;, &quot;Inh&quot;, &quot;GliaProg&quot;, &quot;Immature&quot;,&quot;CorticalHem&quot;, &quot;IPcycling&quot;,   &quot;RGcycling&quot;, &quot;Choroid&quot;,  &quot;Cajal&quot;, &quot;InhGNRH&quot;, &quot;InhThalamic&quot;, &quot;InhMidbrain&quot;, &quot;InhSST&quot;,&quot;VLMC&quot;), function(cell) names(which(abs(m_posterior$PosteriorMean[which(m_posterior$lfsr[,paste0(cell, &quot;21&quot;)] &lt; 0.05), paste0(cell, &quot;21&quot;)])&gt;0.58))) %&gt;%
  unlist() %&gt;% 
  unname() %&gt;% 
  table() %&gt;% as.data.frame() %&gt;% summarize(sum(Freq&lt;=x))) %&gt;% mutate(x=1:18)</code></pre>
<pre><code>   sum(Freq &lt;= x)  x
1            1272  1
2            1972  2
3            2387  3
4            2677  4
5            2937  5
6            3137  6
7            3289  7
8            3393  8
9            3482  9
10           3544 10
11           3597 11
12           3644 12
13           3685 13
14           3719 14
15           3760 15
16           3795 16
17           3820 17
18           3832 18</code></pre>
<p>Because mash gives posterior effect size estimates, we can further
ask how many of the genes that are DE in at least one condition (cell
type:treatment) have effects within a factor of 2.5-fold in K
conditions.</p>
<pre class="r"><code>gene.filter &lt;- apply(m_posterior$lfsr, MARGIN = 1, function(i)sum(i&lt;0.05))
sig.genes &lt;- names(gene.filter)[which(gene.filter&gt;0)]

table(apply(m_posterior$PosteriorMean[sig.genes,], MARGIN = 1, FUN = function(x){sum( x/min(x)&lt;2.5 &amp; x/min(x)&gt; 0.4 )}))</code></pre>
<pre><code>
   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16 
1964 1407 1101 1033  922  920  826  696  623  520  434  394  272  214  193  196 
  17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32 
 213  236  205  124  114   87   77   72   43   53   52   47   60   44   40   53 
  33   34   35   36 
  44   61   27   18 </code></pre>
<p>Note that most effects are shared in a relatively small number of
conditions, with very few genes showing concordant responses across all
cell types and in response to both treatments.</p>
<div id="repeat-with-coarse-classification" class="section level3">
<h3>Repeat with coarse classification</h3>
<pre class="r"><code>de_results_combinedcoarse_filtered_mash &lt;- de_genes_pseudoinput_for_mash(pseudo_input = pseudo_coarse_quality_de, classification = &quot;combined.annotation.coarse.harmony&quot;, model_formula = model_formula, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)</code></pre>
<pre class="r"><code>model_formula_onebatch &lt;- ~  treatment + (1|vireo.individual) 
# adjust de_genes_pseudoinput_for_mash function
pseudo_coarse_quality_de_vlmc &lt;- list()
pseudo_coarse_quality_de_vlmc$counts &lt;-  pseudo_coarse_quality_de$counts[,c(which(pseudo_coarse_quality_de$meta$combined.annotation.coarse.harmony==&quot;VLMC&quot;))]
pseudo_coarse_quality_de_vlmc$meta &lt;- pseudo_coarse_quality_de$meta %&gt;% filter(combined.annotation.coarse.harmony == &quot;VLMC&quot;)

de_results_combinedcoarse_filtered_vlmc &lt;- de_genes_pseudoinput_for_mash(pseudo_input = pseudo_coarse_quality_de_vlmc, classification = &quot;combined.annotation.coarse.harmony&quot;, model_formula = model_formula_onebatch, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)

de_results_combinedcoarse_filtered_mash[[&quot;VLMC&quot;]] &lt;- de_results_combinedcoarse_filtered_vlmc$VLMC

saveRDS(de_results_combinedcoarse_filtered_mash, file =  &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedcoarse_filtered_reharmonize_for_mash_20240731.RDS&quot;)</code></pre>
<pre class="r"><code>res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Glut1=logFC) 

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, RG1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, IP1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Immature1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, NeuronOther1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, VLMC1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Choroid1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Cajal1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Inh1=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glia&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Glia1=logFC) %&gt;% full_join(res)

##

##
res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Glut21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, RG21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, IP21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Immature21=logFC) %&gt;% full_join(res)
res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, NeuronOther21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, VLMC21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Choroid21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Cajal21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Inh21=logFC) %&gt;% full_join(res)

res &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glia&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;%  dplyr::select(gene, Glia21=logFC) %&gt;% full_join(res)

##

mash_de_effect &lt;- res %&gt;%  `rownames&lt;-` (.$gene) %&gt;% dplyr::select(-gene)

# And the standard errors

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Glut1=logFC/t) %&gt;%  dplyr::select(gene, Glut1) 

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(RG1=logFC/t) %&gt;%  dplyr::select(gene, RG1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(IP1=logFC/t) %&gt;%  dplyr::select(gene, IP1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Immature1=logFC/t) %&gt;%  dplyr::select(gene, Immature1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(NeuronOther1=logFC/t) %&gt;%   dplyr::select(gene, NeuronOther1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(VLMC1=logFC/t) %&gt;%  dplyr::select(gene, VLMC1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Choroid1=logFC/t) %&gt;%  dplyr::select(gene, Choroid1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Cajal1=logFC/t) %&gt;%  dplyr::select(gene, Cajal1) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Inh1=logFC/t) %&gt;%  dplyr::select(gene, Inh1) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glia&quot;]], coef = &quot;treatmentstim1pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;)%&gt;% mutate(Glia1=logFC/t) %&gt;%  dplyr::select(gene, Glia1) %&gt;% full_join(se)

##
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glut&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Glut21=logFC/t) %&gt;%  dplyr::select(gene, Glut21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;RG&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(RG21=logFC/t) %&gt;%  dplyr::select(gene, RG21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;IP&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(IP21=logFC/t) %&gt;%  dplyr::select(gene, IP21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Immature&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Immature21=logFC/t) %&gt;%  dplyr::select(gene, Immature21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;NeuronOther&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(NeuronOther21=logFC/t) %&gt;%   dplyr::select(gene, NeuronOther21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;VLMC&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(VLMC21=logFC/t) %&gt;%  dplyr::select(gene, VLMC21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Choroid&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Choroid21=logFC/t) %&gt;%  dplyr::select(gene, Choroid21) %&gt;% full_join(se)

se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Cajal&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Cajal21=logFC/t) %&gt;%  dplyr::select(gene, Cajal21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Inh&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;) %&gt;% mutate(Inh21=logFC/t) %&gt;%  dplyr::select(gene, Inh21) %&gt;% full_join(se)
se &lt;- topTable(de_results_combinedcoarse_filtered_mash[[&quot;Glia&quot;]], coef = &quot;treatmentstim21pct&quot;, number = Inf) %&gt;% rownames_to_column(var = &quot;gene&quot;)%&gt;% mutate(Glia21=logFC/t) %&gt;%  dplyr::select(gene, Glia21) %&gt;% full_join(se)

##


mash_de_se &lt;- se %&gt;%  `rownames&lt;-` (.$gene) %&gt;% dplyr::select(-gene)

mash_dataset9 &lt;- mash_set_data(as.matrix(mash_de_effect), as.matrix(mash_de_se), alpha = 1)
#set up cov matrix
##select strong signals
m.1by1 &lt;- mash_1by1(mash_dataset9)
strong &lt;- get_significant_results(m.1by1, 0.01)

#account for correlations
V.simple = estimate_null_correlation_simple(mash_dataset9, z_thresh = 3)
data.Vsimple = mash_update_data(mash_dataset9, V=V.simple)

dat.strong = list(data.Vsimple$Bhat[strong, ], data.Vsimple$Shat[strong, ])
names(dat.strong) = c(&quot;Bhat&quot;, &quot;Shat&quot;)
dat.random = list(data.Vsimple$Bhat[-strong, ], data.Vsimple$Shat[-strong, ])
names(dat.random) = c(&quot;Bhat&quot;, &quot;Shat&quot;)

#cannonical covariance using all the tests
U.c = cov_canonical(data.Vsimple) 
#data-driven covariance using flashr + pca
U.f = cov_flash(data.Vsimple, subset = strong)
U.pca = cov_pca(data.Vsimple,ifelse(ncol(mash_de_effect)&lt;5, ncol(mash_de_effect), 5),subset=strong)

# Denoised data-driven matrices
# Initialization of udr 
maxiter=1e3
U.init = c(U.f, U.pca)
Vhat = estimate_null_cov_simple(dat.random, est_cor = FALSE)
fit0 &lt;- ud_init(dat.strong$Bhat, U_scaled = U.c, n_rank1 = 0, U_unconstrained = U.init, V = Vhat)

# fit udr model
fit1 &lt;- ud_fit(fit0, control = list(unconstrained.update = &quot;ted&quot;, maxiter = maxiter, tol = 1e-2, tol.lik = 1e-2))

# extract data-driven covariance from udr model. (A list of covariance matrices)
U.ted &lt;- lapply(fit1$U,function (e) &quot;[[&quot;(e,&quot;mat&quot;))

#fit mash model to all the tests
m.Vsimple = mash(data.Vsimple, c(U.c, U.ted)) 
#compute posterior stat
m_posterior &lt;- mash_compute_posterior_matrices(m.Vsimple, data.Vsimple)
saveRDS(m.Vsimple, file=&quot;output/mash_de/mashmodel_dataset9_coarse_reharmonized_z3.RDS&quot;)
saveRDS(m_posterior, file=&quot;output/mash_de/mashposterior_dataset9_coarse_reharmonized_z3.RDS&quot;)</code></pre>
<p>Using these posterior results, I define “shared” effects between any
two conditions as those that are (a) significant in at least one of the
conditions and (b) differ in magnitude by less than a factor of 2.5,
with the same sign.</p>
<p>The matrix of sharing by these criteria is obtained from:</p>
<pre class="r"><code>m_posterior &lt;- readRDS(file=&quot;output/mash_de/mashposterior_dataset9_coarse_reharmonized_z3.RDS&quot;)

shared.size = matrix(NA,nrow = ncol(m_posterior$lfsr),ncol=ncol(m_posterior$lfsr))
colnames(shared.size) &lt;- rownames(shared.size) &lt;-colnames(m_posterior$lfsr)
for (i in 1:ncol(m_posterior$lfsr)) {
  for (j in 1:ncol(m_posterior$lfsr)) {
    sig.row=which(m_posterior$lfsr[,i] &lt; 0.05)
    sig.col=which(m_posterior$lfsr[,j] &lt; 0.05)
    a=(union(sig.row,sig.col)) # at least one effect is significant
    quotient=(m_posterior$PosteriorMean[a,i]/m_posterior$PosteriorMean[a,j])
    shared.size[i,j] = mean(quotient &gt; 0.4 &amp; quotient &lt; 2.5)
  }
}

# alternatively, additionally constrain to a minimum logFC
shared.size.constrained = matrix(NA,nrow = ncol(m_posterior$lfsr),ncol=ncol(m_posterior$lfsr))
colnames(shared.size.constrained) &lt;- rownames(shared.size.constrained) &lt;-colnames(m_posterior$lfsr)
for (i in 1:ncol(m_posterior$lfsr)) {
  for (j in 1:ncol(m_posterior$lfsr)) {
    sig.row=which(m_posterior$lfsr[,i] &lt; 0.05)
    sig.col=which(m_posterior$lfsr[,j] &lt; 0.05)
    size.row=which(abs(m_posterior$PosteriorMean[,i]) &gt; 0.58)
    size.col=which(abs(m_posterior$PosteriorMean[,j]) &gt; 0.58)
    a=intersect(union(sig.row,sig.col), union(size.row, size.col)) # at least one effect is significant
    # constrain to those with at least one posterior mean logFC&gt;0.58
    quotient=(m_posterior$PosteriorMean[a,i]/m_posterior$PosteriorMean[a,j])
    shared.size.constrained[i,j] = mean(quotient &gt; 0.4 &amp; quotient &lt; 2.5 )
  }
}


# reorder the rows and columns for consistent display

shared.size &lt;- shared.size[c( &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;IP21&quot;,  &quot;RG21&quot;,  &quot;Glia21&quot;,   &quot;Inh21&quot;,  &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;IP1&quot;,  &quot;RG1&quot;, &quot;Glia1&quot;,  &quot;Inh1&quot;, &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;),  c( &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;IP21&quot;,  &quot;RG21&quot;,  &quot;Glia21&quot;,   &quot;Inh21&quot;,  &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;IP1&quot;,  &quot;RG1&quot;, &quot;Glia1&quot;,  &quot;Inh1&quot;, &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;)]

shared.size.constrained &lt;- shared.size.constrained[c( &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;IP21&quot;,  &quot;RG21&quot;,  &quot;Glia21&quot;,   &quot;Inh21&quot;,  &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;IP1&quot;,  &quot;RG1&quot;, &quot;Glia1&quot;,  &quot;Inh1&quot;, &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;), c( &quot;Choroid21&quot;, &quot;VLMC21&quot;,  &quot;Cajal21&quot;, &quot;IP21&quot;,  &quot;RG21&quot;,  &quot;Glia21&quot;,   &quot;Inh21&quot;,  &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;Cajal1&quot;,  &quot;IP1&quot;,  &quot;RG1&quot;, &quot;Glia1&quot;,  &quot;Inh1&quot;, &quot;NeuronOther1&quot;,  &quot;Immature1&quot;, &quot;Glut1&quot;)]</code></pre>
<p>Plot the fraction of effects that are shared as a heatmap:</p>
<pre class="r"><code>labels &lt;- data.frame(celltype=str_extract(rownames(shared.size), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(rownames(shared.size), pattern = &quot;[:digit:]+&quot;))
rownames(labels) &lt;- rownames(shared.size)

celltypeCol &lt;- manual_palette_coarse

treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

# now use pheatmap to annotate
pheatmap(shared.size, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(50),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_row = labels,
         annotation_colors = annoCol, cluster_rows = FALSE, cluster_cols = FALSE
)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-45-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code># for logFC-constrained
labels &lt;- data.frame(celltype=str_extract(rownames(shared.size.constrained), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(rownames(shared.size.constrained), pattern = &quot;[:digit:]+&quot;))
rownames(labels) &lt;- rownames(shared.size.constrained)

celltypeCol &lt;- manual_palette_coarse
treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

pheatmap(shared.size.constrained, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(50),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_row = labels,
         annotation_colors = annoCol, cluster_rows = FALSE, cluster_cols = FALSE
)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-45-2.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="gene-set-enrichment" class="section level2">
<h2>Gene set enrichment</h2>
<p>We used fgsea to compare differential expression results to annotated
gene sets from MsigDB.</p>
<pre class="r"><code>m_posterior &lt;- readRDS(file=&quot;output/mash_de/mashposterior_dataset9_fine_reharmonized_z3.RDS&quot;)</code></pre>
<pre class="r"><code>library(fgsea)
pathways_all &lt;- gmtPathways(&#39;/project/gilad/umans/references/msigdb/h.all.v2023.1.Hs.symbols.gmt&#39;) 
# obtained from https://www.gsea-msigdb.org/gsea/msigdb/collections.jsp</code></pre>
<p>Calculate a t-statistic for mash output, as very small lfsr
significance metrics can skew fgsea results.</p>
<pre class="r"><code>m_posterior$t &lt;- m_posterior$PosteriorMean/m_posterior$PosteriorSD</code></pre>
<p>Next, perform fgsea on each cell type/condition (ie, each column of
this matrix).</p>
<pre class="r"><code>for (i in colnames(m_posterior$t)){
  ranks &lt;- m_posterior$t[, i]
  fgseaRes &lt;- fgsea(pathways = pathways_all, 
                  stats    = ranks,
                  scoreType = &quot;std&quot;,
                  eps = 0,
                  nproc = 5)
  all &lt;- fgseaRes[order(abs(fgseaRes$pval), decreasing = FALSE),]
  write_tsv(all, file = paste0(&quot;/project2/gilad/umans/oxygen_eqtl/output/fgsea/&quot;, i, &quot;_fgsea_all_reharmonized_fine.txt&quot;), quote = &quot;none&quot;, col_names = TRUE)
  rm(all, ranks, fgseaRes)
}</code></pre>
<p>Combine the output into a single matrix and plot the normalized
effect sizes</p>
<pre class="r"><code>combined_fgsea_all &lt;- read_tsv(file = paste0(&quot;/project2/gilad/umans/oxygen_eqtl/output/fgsea/&quot;, colnames(m_posterior$t)[1], &quot;_fgsea_all_reharmonized_fine.txt&quot;), col_names = TRUE) %&gt;% dplyr::select(pathway, !!colnames(m_posterior$t)[1] := NES)</code></pre>
<pre><code>Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre class="r"><code>for (i in colnames(m_posterior$t)[-1]){
  temp &lt;- read_tsv(file = paste0(&quot;/project2/gilad/umans/oxygen_eqtl/output/fgsea/&quot;, i, &quot;_fgsea_all_reharmonized_fine.txt&quot;), col_names = TRUE) %&gt;% dplyr::select(pathway, !!i := NES)
  combined_fgsea_all &lt;- full_join(combined_fgsea_all, temp, by = &quot;pathway&quot;)
  rm(temp)
}</code></pre>
<pre><code>Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre class="r"><code>combined_fgsea_all &lt;- combined_fgsea_all %&gt;% column_to_rownames(var = &quot;pathway&quot;)


labels &lt;- data.frame(celltype=str_extract(colnames(combined_fgsea_all), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(colnames(combined_fgsea_all), pattern = &quot;[:digit:]+&quot;))

rownames(labels) &lt;- colnames(combined_fgsea_all)

celltypeCol &lt;- manual_palette_fine
treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

combined_fgsea_all &lt;- combined_fgsea_all[, c(&quot;RGcycling21&quot; , &quot;RG21&quot;, &quot;CorticalHem21&quot;, &quot;IPcycling21&quot;, &quot;IP21&quot;, &quot;GliaProg21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;GlutNTS21&quot;, &quot;NeuronOther21&quot;, &quot;Cajal21&quot;,  &quot;Inh21&quot;,  &quot;InhThalamic21&quot;, &quot;InhGNRH21&quot;,  &quot;InhSST21&quot;, &quot;InhMidbrain21&quot;, &quot;VLMC21&quot;, &quot;Choroid21&quot;, &quot;RGcycling1&quot; , &quot;RG1&quot;, &quot;CorticalHem1&quot;, &quot;IPcycling1&quot;, &quot;IP1&quot;, &quot;GliaProg1&quot;, &quot;Immature1&quot;, &quot;Glut1&quot;, &quot;GlutNTS1&quot;, &quot;NeuronOther1&quot;, &quot;Cajal1&quot;,  &quot;Inh1&quot;,  &quot;InhThalamic1&quot;, &quot;InhGNRH1&quot;,  &quot;InhSST1&quot;, &quot;InhMidbrain1&quot;, &quot;VLMC1&quot;, &quot;Choroid1&quot;)]


# now use pheatmap to annotate
pheatmap(combined_fgsea_all, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(25),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_col = labels,
         annotation_colors = annoCol, cluster_cols = FALSE
         )</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-50-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>rm(combined_fgsea_all, m_posterior)</code></pre>
<div id="gene-set-enrichment-coarse-cell-classification"
class="section level3">
<h3>Gene set enrichment, coarse cell classification:</h3>
<pre class="r"><code>m_posterior &lt;- readRDS(file=&quot;output/mash_de/mashposterior_dataset9_coarse_reharmonized_z3.RDS&quot;)
m_posterior$t &lt;- m_posterior$PosteriorMean/m_posterior$PosteriorSD</code></pre>
<p>Next, perform fgsea on each cell type/condition (ie, each column of
this matrix).</p>
<pre class="r"><code>for (i in colnames(m_posterior$t)){
  ranks &lt;- m_posterior$t[, i]
  fgseaRes &lt;- fgsea(pathways = pathways_all, 
                    stats    = ranks,
                    scoreType = &quot;std&quot;,
                    eps = 0,
                    nproc = 5)
  all &lt;- fgseaRes[order(abs(fgseaRes$pval), decreasing = FALSE),]
  write_tsv(all, file = paste0(&quot;/project2/gilad/umans/oxygen_eqtl/output/fgsea/&quot;, i, &quot;_fgsea_all_reharmonized_coarse.txt&quot;), quote = &quot;none&quot;, col_names = TRUE)
  rm(all, ranks, fgseaRes)
}</code></pre>
<p>Combine the output into a single matrix and plot the normalized
effect sizes</p>
<pre class="r"><code>combined_fgsea_all &lt;- read_tsv(file = paste0(&quot;/project2/gilad/umans/oxygen_eqtl/output/fgsea/&quot;, colnames(m_posterior$t)[1], &quot;_fgsea_all_reharmonized_coarse.txt&quot;), col_names = TRUE) %&gt;% dplyr::select(pathway, !!colnames(m_posterior$t)[1] := NES)</code></pre>
<pre><code>Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre class="r"><code>for (i in colnames(m_posterior$t)[-1]){
  temp &lt;- read_tsv(file = paste0(&quot;/project2/gilad/umans/oxygen_eqtl/output/fgsea/&quot;, i, &quot;_fgsea_all_reharmonized_coarse.txt&quot;), col_names = TRUE) %&gt;% dplyr::select(pathway, !!i := NES)
  combined_fgsea_all &lt;- full_join(combined_fgsea_all, temp, by = &quot;pathway&quot;)
  rm(temp)
}</code></pre>
<pre><code>Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
Rows: 50 Columns: 8
── Column specification ────────────────────────────────────────────────────────
Delimiter: &quot;\t&quot;
chr (1): pathway
dbl (6): pval, padj, log2err, ES, NES, size
lgl (1): leadingEdge

ℹ Use `spec()` to retrieve the full column specification for this data.
ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre class="r"><code>combined_fgsea_all &lt;- combined_fgsea_all %&gt;% column_to_rownames(var = &quot;pathway&quot;)


labels &lt;- data.frame(celltype=str_extract(colnames(combined_fgsea_all), pattern = &quot;[:alpha:]+&quot;),
                     treatment=str_extract(colnames(combined_fgsea_all), pattern = &quot;[:digit:]+&quot;))

rownames(labels) &lt;- colnames(combined_fgsea_all)

celltypeCol &lt;- manual_palette_coarse
treatmentCol &lt;- c(&quot;red&quot;, &quot;blue&quot;)
names(treatmentCol) &lt;- unique(labels$treatment)
annoCol &lt;- list(celltype = celltypeCol,
                treatment = treatmentCol)

combined_fgsea_all &lt;- combined_fgsea_all[, c( &quot;RG21&quot;, &quot;IP21&quot;, &quot;Glia21&quot;, &quot;Immature21&quot;, &quot;Glut21&quot;, &quot;NeuronOther21&quot;, &quot;Cajal21&quot;,  &quot;Inh21&quot;, &quot;VLMC21&quot;, &quot;Choroid21&quot;, &quot;RG1&quot;, &quot;IP1&quot;, &quot;Glia1&quot;, &quot;Immature1&quot;, &quot;Glut1&quot;,&quot;NeuronOther1&quot;, &quot;Cajal1&quot;,  &quot;Inh1&quot;, &quot;VLMC1&quot;, &quot;Choroid1&quot;)]


# now use pheatmap to annotate
pheatmap(combined_fgsea_all, col = colorRampPalette(rev(brewer.pal(11, &quot;Spectral&quot;)))(25),
         border_color = NA,
         show_colnames = TRUE,
         treeheight_row = 0, treeheight_col = 0,
         annotation_col = labels,
         annotation_colors = annoCol, cluster_cols = FALSE
)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-53-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>rm(combined_fgsea_all, m_posterior)</code></pre>
</div>
</div>
<div id="stressed-cell-annotation" class="section level2">
<h2>Stressed cell annotation</h2>
<p>We used the <a
href="https://www.embopress.org/doi/full/10.15252/embj.2022111118">Gruffi</a>
software tool to identify highly hypoxia- and hyperoxia-responsive cells
in our dataset. Gruffi works by first clustering single-cell data very
finely into “neighborhoods” of similar cells, helping to smooth some of
the sparsity of single-cell measurements. Scores based on chosen gene
lists are then calculated and used to set high- and low-pass filters for
cell classification.</p>
<p>In the default Gruffi use case, “stressed” cells are identified by
high expression of glycolytic and ER stress-related genes. However, in
our experiment, environmental oxygen was directly modulated, meaning
that responsive cells should be identifiable based on genes that change
under these conditions. In our initial analyses, we confirmed that gene
module scores obtained from these default gene lists were poorly
correlated with the treatment condition of a given cell neighborhood,
with the exception of the glycolytic (<a href="GO:0006096"
class="uri">GO:0006096</a>) gene module and hypoxia exposure. Instead,
we first obtained alternative gene lists based on the estimates of DE
sharing provided by mash. These gene lists were used to identify
treatment-responsive cells in both the hyperoxia and hypoxia conditions
separately. Note that although these gene lists are non-overlapping, it
is possible for cells to be classified as hypoxia- or
hyperoxia-responsive, or both, in any treatment condition, although we
expect that hypoxia exposure should increase the proportion of
hypoxia-responsive cells and decrease hyperoxia-responsive cells, and
vice-versa.</p>
<pre class="r"><code>m_posterior &lt;- readRDS(file=&quot;output/mash_de/mashposterior_dataset9_fine_reharmonized_z3.RDS&quot;)

m_posterior_hypoxia&lt;- list()
m_posterior_hypoxia$lfsr &lt;- m_posterior$lfsr[,c(&quot;RGcycling1&quot;, &quot;InhThalamic1&quot;, &quot;InhSST1&quot;,  &quot;InhGNRH1&quot;, &quot;IPcycling1&quot;, &quot;GlutNTS1&quot;, &quot;GliaProg1&quot;, &quot;CorticalHem1&quot;, &quot;Inh1&quot;, &quot;Cajal1&quot;, &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;NeuronOther1&quot;, &quot;Immature1&quot;, &quot;IP1&quot;, &quot;RG1&quot;, &quot;Glut1&quot;)]
m_posterior_hypoxia$PosteriorMean &lt;- m_posterior$PosteriorMean[,c(&quot;RGcycling1&quot;, &quot;InhThalamic1&quot;, &quot;InhSST1&quot;,  &quot;InhGNRH1&quot;, &quot;IPcycling1&quot;, &quot;GlutNTS1&quot;, &quot;GliaProg1&quot;, &quot;CorticalHem1&quot;, &quot;Inh1&quot;, &quot;Cajal1&quot;, &quot;Choroid1&quot;, &quot;VLMC1&quot;, &quot;NeuronOther1&quot;, &quot;Immature1&quot;, &quot;IP1&quot;, &quot;RG1&quot;, &quot;Glut1&quot;)]

# start with genes that are significantly DE in all tested cell types 
gene.filter &lt;- apply(m_posterior_hypoxia$lfsr, MARGIN = 1, function(i)sum(i&gt;0.05))
shared.genes &lt;- names(gene.filter)[which(gene.filter==0)]

filtered.shared.genes.hypoxia &lt;- shared.genes[apply(m_posterior_hypoxia$PosteriorMean[shared.genes,], MARGIN = 1, FUN = function(x){all(abs(x)/median(abs(x))&lt;5 &amp; sign(x)&gt;0) &amp; mean(x)&gt;1 })]

filtered.shared.genes.hypoxia</code></pre>
<pre><code> [1] &quot;BNIP3&quot;       &quot;IGFBP2&quot;      &quot;PGAM1&quot;       &quot;BNIP3L&quot;      &quot;FAM162A&quot;    
 [6] &quot;TPI1&quot;        &quot;PGK1&quot;        &quot;P4HA1&quot;       &quot;ENO1&quot;        &quot;LDHA&quot;       
[11] &quot;MIR210HG&quot;    &quot;ALDOA&quot;       &quot;AC097534.2&quot;  &quot;MTFP1&quot;       &quot;AK4&quot;        
[16] &quot;SLC2A1&quot;      &quot;VEGFA&quot;       &quot;PDK1&quot;        &quot;RCOR2&quot;       &quot;ANKRD37&quot;    
[21] &quot;PLOD2&quot;       &quot;HK2&quot;         &quot;TNIP1&quot;       &quot;DDIT4&quot;       &quot;AC107021.1&quot; 
[26] &quot;INSIG2&quot;      &quot;WSB1&quot;        &quot;NRN1&quot;        &quot;PPFIA4&quot;      &quot;EGLN1&quot;      
[31] &quot;RAPGEF4&quot;     &quot;FAM210A&quot;     &quot;P4HA2&quot;       &quot;CXCR4&quot;       &quot;GOLGA8A&quot;    
[36] &quot;ENO2&quot;        &quot;SNHG19&quot;      &quot;GPI&quot;         &quot;HLA-B&quot;       &quot;MT3&quot;        
[41] &quot;ADAMTS20&quot;    &quot;PFKP&quot;        &quot;PFKFB3&quot;      &quot;HILPDA&quot;      &quot;KDM3A&quot;      
[46] &quot;RLF&quot;         &quot;KDM7A&quot;       &quot;AC087280.2&quot;  &quot;HK1&quot;         &quot;PDK3&quot;       
[51] &quot;LINC02649&quot;   &quot;FUT11&quot;       &quot;NIM1K&quot;       &quot;COL11A1&quot;     &quot;AL357153.2&quot; 
[56] &quot;KDM4C&quot;       &quot;UACA&quot;        &quot;SLC16A1&quot;     &quot;USP28&quot;       &quot;SLC8A3&quot;     
[61] &quot;RASGRF1&quot;     &quot;NRIP3&quot;       &quot;PRMT8&quot;       &quot;NDRG1&quot;       &quot;PCAT6&quot;      
[66] &quot;RAPGEF4-AS1&quot;</code></pre>
<pre class="r"><code>m_posterior_hyperoxia&lt;- list()
m_posterior_hyperoxia$lfsr &lt;- m_posterior$lfsr[,c(&quot;RGcycling21&quot;, &quot;InhThalamic21&quot;, &quot;InhSST21&quot;,  &quot;InhGNRH21&quot;, &quot;IPcycling21&quot;, &quot;GlutNTS21&quot;, &quot;GliaProg21&quot;, &quot;CorticalHem21&quot;, &quot;Inh21&quot;, &quot;Cajal21&quot;, &quot;Choroid21&quot;, &quot;VLMC21&quot;, &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;IP21&quot;, &quot;RG21&quot;, &quot;Glut21&quot;)]

m_posterior_hyperoxia$PosteriorMean &lt;- m_posterior$PosteriorMean[,c(&quot;RGcycling21&quot;, &quot;InhThalamic21&quot;, &quot;InhSST21&quot;, &quot;InhGNRH21&quot;, &quot;IPcycling21&quot;, &quot;GlutNTS21&quot;, &quot;GliaProg21&quot;, &quot;CorticalHem21&quot;, &quot;Inh21&quot;, &quot;Cajal21&quot;, &quot;Choroid21&quot;, &quot;VLMC21&quot;, &quot;NeuronOther21&quot;, &quot;Immature21&quot;, &quot;IP21&quot;, &quot;RG21&quot;, &quot;Glut21&quot;)]


gene.filter &lt;- apply(m_posterior_hyperoxia$lfsr, MARGIN = 1, function(i)sum(i&gt;0.05))
shared.genes &lt;- names(gene.filter)[which(gene.filter==0)]

filtered.shared.genes.hyperoxia &lt;- shared.genes[apply(m_posterior_hyperoxia$PosteriorMean[shared.genes,], MARGIN = 1, FUN = function(x){all(abs(x)/median(abs(x))&lt;5 &amp; sign(x)&gt;0) &amp; mean(x)&gt;0.6 })]

filtered.shared.genes.hyperoxia</code></pre>
<pre><code>[1] &quot;RPS20&quot;     &quot;RBM3&quot;      &quot;NUDT3&quot;     &quot;USP13&quot;     &quot;GALNT17&quot;   &quot;LINC01619&quot;
[7] &quot;SLC7A11&quot;  </code></pre>
<p>Note that these are distinct gene sets.</p>
<pre class="r"><code>length(intersect(filtered.shared.genes.hyperoxia, filtered.shared.genes.hypoxia))</code></pre>
<pre><code>[1] 0</code></pre>
<p>These gene sets were then used as input for Gruffi, following their
standard workflow outlined on the software’s <a
href="https://github.com/jn-goe/gruffi">Github page</a>.</p>
<pre class="r"><code>library(gruffi)

harmony.batchandindividual.sct &lt;- Seurat.utils::SetupReductionsNtoKdimensions(obj = harmony.batchandindividual.sct, nPCs = 50, dimensions=3:2, reduction=&quot;umap&quot;)
harmony.batchandindividual.sct &lt;- AutoFindGranuleResolution(obj = harmony.batchandindividual.sct, assay = &quot;SCT&quot;)
granule.res.4.gruffi &lt;- harmony.batchandindividual.sct@misc$gruffi$&#39;optimal.granule.res&#39;
harmony.batchandindividual.sct &lt;- ReassignSmallClusters(harmony.batchandindividual.sct, ident = granule.res.4.gruffi) 
granule.res.4.gruffi &lt;- paste0(granule.res.4.gruffi, &#39;.reassigned&#39;)</code></pre>
<p>Score the default Gruffi GO terms as well as our custom gene
lists:</p>
<pre class="r"><code>go1 &lt;- &quot;GO:0006096&quot; # Glycolysis
go2 &lt;- &quot;GO:0034976&quot; # ER-stress
go3 &lt;- &quot;GO:0042063&quot; # Gliogenesis, negative filtering
# Glycolytic process    GO:0006096
harmony.batchandindividual.sct &lt;- AssignGranuleAverageScoresFromGOterm(obj = harmony.batchandindividual.sct, GO_term = go1, save.UMAP = TRUE, new_GO_term_computation = T, clustering = granule.res.4.gruffi, plot.each.gene = F)

# ER stress     GO:0034976
harmony.batchandindividual.sct &lt;- AssignGranuleAverageScoresFromGOterm(obj = harmony.batchandindividual.sct, GO_term = go2, save.UMAP = TRUE, new_GO_term_computation = T, clustering = granule.res.4.gruffi, plot.each.gene = F)

# Gliogenesis       GO:0042063
harmony.batchandindividual.sct &lt;- AssignGranuleAverageScoresFromGOterm(obj = harmony.batchandindividual.sct, GO_term = go3, save.UMAP = TRUE, new_GO_term_computation = T, clustering = granule.res.4.gruffi, plot.each.gene = F)</code></pre>
<p>Score the custom gene lists:</p>
<pre class="r"><code>harmony.batchandindividual.sct &lt;- AddModuleScore(harmony.batchandindividual.sct, features = list(filtered.shared.genes.hypoxia), assay = &quot;RNA&quot;, name = &quot;mash_hypoxia&quot;)

harmony.batchandindividual.sct &lt;- CustomScoreEvaluation(obj = harmony.batchandindividual.sct, custom.score.name = &quot;mash_hypoxia1&quot;, clustering = &quot;SCT_snn_res.105.reassigned&quot;)

# due to a bug in this version of Gruffi, custom scores are stored as factors rather than numeric values, so that needs to be converted before further calculations
harmony.batchandindividual.sct$SCT_snn_res.105.reassigned_cl.av_mash_hypoxia1 &lt;- as.numeric(levels(harmony.batchandindividual.sct$SCT_snn_res.105.reassigned_cl.av_mash_hypoxia1))[harmony.batchandindividual.sct$SCT_snn_res.105.reassigned_cl.av_mash_hypoxia1]

harmony.batchandindividual.sct &lt;- AddModuleScore(harmony.batchandindividual.sct, features = list(filtered.shared.genes.hyperoxia), assay = &quot;RNA&quot;, name = &quot;mash_hyperoxia&quot;)

harmony.batchandindividual.sct &lt;- CustomScoreEvaluation(obj = harmony.batchandindividual.sct, custom.score.name = &quot;mash_hyperoxia1&quot;, clustering = &quot;SCT_snn_res.105.reassigned&quot;)

# due to a bug in this version of Gruffi, custom scores are stored as factors rather than numeric values, so that needs to be converted before further calculations
harmony.batchandindividual.sct$SCT_snn_res.105.reassigned_cl.av_mash_hyperoxia1 &lt;- as.numeric(levels(harmony.batchandindividual.sct$SCT_snn_res.105.reassigned_cl.av_mash_hyperoxia1))[harmony.batchandindividual.sct$SCT_snn_res.105.reassigned_cl.av_mash_hyperoxia1]</code></pre>
<p>Now use Gruffi’s interactive tool to check the thresholded scores.
Here, I use only the custom-calculated scores and the default negative
selection score, and allow the thresholds to be chosen
automatically.</p>
<pre class="r"><code>i1 &lt;- &quot;SCT_snn_res.105.reassigned_cl.av_mash_hypoxia1&quot;
(i3 &lt;- Stringendo::kppu(granule.res.4.gruffi, &#39;cl.av&#39;, &quot;GO.0042063&quot;))

# Call Shiny app
harmony.batchandindividual.sct &lt;- FindThresholdsShiny(obj = harmony.batchandindividual.sct,
                                stress.ident1 = i1,
                                stress.ident2 = i1,
                                notstress.ident3 = i3)
# Mash score auto set at 3.421, gliogenesis score auto set at 3.191

meta_export &lt;- harmony.batchandindividual.sct@meta.data
saveRDS(meta_export, file = &quot;post_gruffi_metadata_hypoxia_mash_reharmonized_remashed.RDS&quot;)</code></pre>
<pre class="r"><code>i1 &lt;- &quot;SCT_snn_res.105.reassigned_cl.av_mash_hyperoxia1&quot;

# Call Shiny app
harmony.batchandindividual.sct &lt;- FindThresholdsShiny(obj = harmony.batchandindividual.sct,
                                stress.ident1 = i1,
                                stress.ident2 = i1,
                                notstress.ident3 = i3)
# mash score auto set to 4.832, gliogenesis score auto set to 3.191

meta_export_hyperox &lt;- harmony.batchandindividual.sct@meta.data
saveRDS(meta_export_hyperox, file = &quot;post_gruffi_metadata_hyperox_mash_reharmonized_remashed.RDS&quot;)</code></pre>
<p>I also do the same for the default Gruffi gene sets:</p>
<pre class="r"><code>(i1 &lt;- Stringendo::kppu(granule.res.4.gruffi, &#39;cl.av&#39;, &quot;GO.0006096&quot;))
(i2 &lt;- Stringendo::kppu(granule.res.4.gruffi, &#39;cl.av&#39;, &quot;GO.0034976&quot;))
(i3 &lt;- Stringendo::kppu(granule.res.4.gruffi, &#39;cl.av&#39;, &quot;GO.0042063&quot;))

# Call Shiny app
harmony.batchandindividual.sct &lt;- FindThresholdsShiny(obj = harmony.batchandindividual.sct,
                                stress.ident1 = i1,
                                stress.ident2 = i2,
                                notstress.ident3 = i3)

# auto thresholds are 2.488 for GO.0006096, 1.429 for GO.0034976, and 3.191 for GO.0042063
meta_export_default &lt;- harmony.batchandindividual.sct@meta.data
saveRDS(meta_export_default, file = &quot;post_gruffi_metadata_default_mash_reharmonized.RDS&quot;)</code></pre>
<p>Next, attach the hypoxia and hyperoxia response annotations from
Gruffi to the working Seurat object and classify cells as
responsive/unresponsive. Now do the same with the mash scores</p>
<pre class="r"><code>hypoxia_stressed_mash &lt;- readRDS(file = &quot;output/post_gruffi_metadata_hypoxia_mash_reharmonized_remashed.RDS&quot;) %&gt;% select(hypoxia_stressed_mash = `is.Stressed`)
hyperoxia_stressed_mash &lt;- readRDS(file = &quot;output/post_gruffi_metadata_hyperox_mash_reharmonized_remashed.RDS&quot;) %&gt;% select(hyperoxia_stressed_mash= `is.Stressed`)</code></pre>
<pre class="r"><code>harmony.batchandindividual.sct &lt;- AddMetaData(harmony.batchandindividual.sct, metadata = hypoxia_stressed_mash)
harmony.batchandindividual.sct &lt;- AddMetaData(harmony.batchandindividual.sct, metadata = hyperoxia_stressed_mash)
# and, add a combined column called &quot;gruffi_label&quot; that incorporates both hypoxia and hyperoxia stress scores
harmony.batchandindividual.sct$gruffi_label_mash &lt;- harmony.batchandindividual.sct@meta.data %&gt;% select(hypoxia_stressed_mash, hyperoxia_stressed_mash) %&gt;% mutate(hypoxia = 2* hypoxia_stressed_mash) %&gt;% mutate(stressed = hyperoxia_stressed_mash + hypoxia)  %&gt;% mutate(stressed_label = case_match(stressed, 0 ~ &quot;unstressed&quot;, 1 ~ &quot;hyperoxia_stressed&quot;, 2 ~ &quot;hypoxia_stressed&quot;, 3 ~ &quot;double_stressed&quot;)) %&gt;% select(stressed_label)</code></pre>
<p>For the default Gruffi gene sets, I will do this only for the hypoxia
condition, as we previously determined that the scores are largely
unresponsive to hyperoxic treatment:</p>
<pre class="r"><code>hypoxia_stressed &lt;- readRDS(file = &quot;output/post_gruffi_metadata_default_mash_reharmonized.RDS&quot;) %&gt;% select(hypoxia_stressed = `is.Stressed`)

harmony.batchandindividual.sct &lt;- AddMetaData(harmony.batchandindividual.sct, metadata = hypoxia_stressed)
# and, add a combined column called &quot;gruffi_label&quot; that incorporates both hypoxia and hyperoxia stress scores
harmony.batchandindividual.sct$gruffi_label &lt;- harmony.batchandindividual.sct@meta.data %&gt;% 
  select(hypoxia_stressed) %&gt;%
  mutate(stressed = 1* hypoxia_stressed)  %&gt;% 
  mutate(stressed_label = case_match(stressed, 0 ~ &quot;unstressed&quot;, 1 ~ &quot;hypoxia_stressed&quot;)) %&gt;%
  select(stressed_label)</code></pre>
<p>Now, for both the fine and coarse clustering, calculate the
fractional change in the responsive cell proportion across treatment
conditions.</p>
<p>First, in the coarse classification:</p>
<pre class="r"><code>stressed_table &lt;- as.data.frame(table(harmony.batchandindividual.sct$gruffi_label_mash, harmony.batchandindividual.sct$combined.annotation.coarse.harmony, harmony.batchandindividual.sct$treatment)) %&gt;%
  mutate(Freq = Freq+1) %&gt;% #add pseudocount of one cell to avoid a divide by potential zero problem
  group_by(Var3, Var2) %&gt;%
  mutate(totals=sum(Freq)) %&gt;% 
  ungroup() %&gt;% 
  mutate(fraction=round(Freq/totals, digits=3))

stressed_table %&gt;% dplyr::select(Var1, Var2, Var3, fraction) %&gt;% 
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;% 
  mutate(control10 =  na_if(x = control10, y = 0)) %&gt;% mutate(change1_10=(stim1pct-control10)/control10) %&gt;%  
  replace_na(list(change1_10=0)) %&gt;% 
  # filter(Var1 != &quot;double_stressed&quot;)  %&gt;%
  # filter(Var1 != &quot;unstressed&quot;) %&gt;% 
  # filter(Var1 != &quot;hyperoxia_stressed&quot;) %&gt;% 
  ggplot(aes(x=reorder(Var2, -change1_10), y=change1_10, color=Var1)) + 
  geom_point(size=2) + 
  coord_flip() + 
  ylab(&quot;Gruffi (mash) stress fraction change (control vs 1%)&quot;) + 
  xlab(&quot;Cell type&quot;) +  
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;),  name=&quot;Stress classification&quot;) + 
  theme_light()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-66-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>stressed_table %&gt;% dplyr::select(Var1, Var2, Var3, fraction) %&gt;% 
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;% 
  mutate(control10 =  na_if(x = control10, y = 0)) %&gt;% 
  mutate(change21_10=(stim21pct-control10)/control10) %&gt;%  
  replace_na(list(change21_10=0)) %&gt;% 
  # filter(Var1 != &quot;double_stressed&quot;)  %&gt;%
  # filter(Var1 != &quot;unstressed&quot;) %&gt;% 
  ggplot(aes(x=reorder(Var2, -change21_10), y=change21_10, color=Var1)) + 
  geom_point(size=2) + 
  coord_flip() + 
  ylab(&quot;Gruffi (mash) stress fraction change (control vs 21%)&quot;) + 
  xlab(&quot;Cell type&quot;)+  
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;), name=&quot;Stress classification&quot;) +
  theme_light()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-66-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Now using the fine classification:</p>
<pre class="r"><code>stressed_table &lt;- as.data.frame(table(harmony.batchandindividual.sct$gruffi_label_mash, harmony.batchandindividual.sct$combined.annotation.fine.harmony, harmony.batchandindividual.sct$treatment)) %&gt;%
  mutate(Freq = Freq+1) %&gt;%
  group_by(Var3, Var2) %&gt;% 
  mutate(totals=sum(Freq)) %&gt;%
  ungroup() %&gt;%
  mutate(fraction=round(Freq/totals, digits=3))

stressed_table %&gt;% dplyr::select(Var1, Var2, Var3, fraction) %&gt;% 
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;% 
  mutate(control10 =  na_if(x = control10, y = 0)) %&gt;% 
  mutate(change1_10=(stim1pct-control10)/control10) %&gt;%  
  replace_na(list(change1_10=0)) %&gt;% 
  # filter(Var1 != &quot;double_stressed&quot;)  %&gt;%
  # filter(Var1 != &quot;unstressed&quot;) %&gt;% 
  ggplot(aes(x=reorder(Var2, -change1_10), y=change1_10, color=Var1)) +
  geom_point(size=2) + 
  coord_flip() + 
  ylab(&quot;Gruffi (mash) stress fraction change (control vs 1%)&quot;) + 
  xlab(&quot;Cell type&quot;) +  
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;), name=&quot;Stress classification&quot;) + 
  theme_light()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-67-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>stressed_table %&gt;% dplyr::select(Var1, Var2, Var3, fraction) %&gt;% 
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;% 
  mutate(control10 =  na_if(x = control10, y = 0)) %&gt;%
  mutate(change21_10=(stim21pct-control10)/control10) %&gt;%  
  replace_na(list(change21_10=0)) %&gt;% 
  # filter(Var1 != &quot;double_stressed&quot;)  %&gt;%
  # filter(Var1 != &quot;unstressed&quot;) %&gt;% 
  ggplot(aes(x=reorder(Var2, -change21_10), y=change21_10, color=Var1)) + 
  geom_point(size=2) + 
  coord_flip() + 
  ylab(&quot;Gruffi (mash) stress fraction change (control vs 21%)&quot;) +
  xlab(&quot;Cell type&quot;) +
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;), name=&quot;Stress classification&quot;) +
  theme_light()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-67-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Plot the default Gruffi scores:</p>
<pre class="r"><code>stressed_table &lt;- as.data.frame(table(harmony.batchandindividual.sct$gruffi_label, harmony.batchandindividual.sct$combined.annotation.coarse.harmony, harmony.batchandindividual.sct$treatment)) %&gt;%
  mutate(Freq = Freq+1) %&gt;% 
  group_by(Var3, Var2) %&gt;% 
  mutate(totals=sum(Freq)) %&gt;% 
  ungroup() %&gt;% mutate(fraction=round(Freq/totals, digits=3))

stressed_table %&gt;% dplyr::select(Var1, Var2, Var3, fraction) %&gt;% 
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;% 
  mutate(control10 =  na_if(x = control10, y = 0)) %&gt;% 
  mutate(change1_10=(stim1pct-control10)/control10) %&gt;%  
  replace_na(list(change1_10=0)) %&gt;% 
  filter(Var1 != &quot;unstressed&quot;) %&gt;%
  ggplot(aes(x=reorder(Var2, -change1_10), y=change1_10, color=Var1)) + 
  geom_point(size=2) + 
  coord_flip() + 
  ylab(&quot;Gruffi (default) stress fraction change (control vs 1%)&quot;) + 
  xlab(&quot;Cell type&quot;) + 
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;), name=&quot;Stress classification&quot;) +
  theme_light()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-68-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>stressed_table &lt;- as.data.frame(table(harmony.batchandindividual.sct$gruffi_label, harmony.batchandindividual.sct$combined.annotation.fine.harmony, harmony.batchandindividual.sct$treatment)) %&gt;%
  group_by(Var3, Var2) %&gt;%
  mutate(totals=sum(Freq)) %&gt;%
  ungroup() %&gt;% 
  mutate(fraction=round(Freq/totals, digits=3))

stressed_table %&gt;% 
  select(Var1, Var2, Var3, fraction) %&gt;%
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;%
  mutate(control10 =  na_if(control10, 0)) %&gt;%
  mutate(change1_10=(stim1pct-control10)/control10) %&gt;%
  replace_na(list(change1_10=0)) %&gt;%
  filter(Var1 != &quot;unstressed&quot;) %&gt;%
  ggplot(aes(x=reorder(Var2, -change1_10), y=change1_10, color=Var1)) + 
  geom_point() + 
  coord_flip() + 
  ylab(&quot;Gruffi (default) stress fraction change (control vs 1%)&quot;) + 
  xlab(&quot;Cell type&quot;)+ 
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;), name=&quot;Stress classification&quot;) +
  theme_light()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-68-2.png" width="672" style="display: block; margin: auto;" /></p>
<p>Look at the individual variability in hypoxia scores by individual in
the coarse groupings:</p>
<pre class="r"><code>stressed_table &lt;- as.data.frame(table(harmony.batchandindividual.sct$gruffi_label_mash, harmony.batchandindividual.sct$combined.annotation.coarse.harmony, harmony.batchandindividual.sct$treatment, harmony.batchandindividual.sct$vireo.individual)) %&gt;% 
  mutate(Freq = Freq+1) %&gt;%
  group_by(Var3, Var2, Var4) %&gt;% 
  mutate(totals=sum(Freq)) %&gt;% 
  ungroup() %&gt;%
  mutate(fraction=round(Freq/totals, digits=3))

stressed_table %&gt;% 
  dplyr::select(Var1, Var2, Var3, Var4, fraction) %&gt;%
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;%
  mutate(control10 =  na_if(control10, 0)) %&gt;%
  mutate(change1_10=(stim1pct-control10)/control10) %&gt;%
  replace_na(list(change1_10=0)) %&gt;%
  filter(Var1 != &quot;double_stressed&quot;)  %&gt;%
  filter(Var1 != &quot;unstressed&quot;) %&gt;%
  filter(Var1 != &quot;hyperoxia_stressed&quot;) %&gt;%
  ggplot(aes(x=reorder(Var2, -change1_10), y=change1_10, color=Var1)) +
  geom_point() + 
  coord_flip() + 
  ylab(&quot;Gruffi (mash) stress fraction change (control vs 1%)&quot;) +
  xlab(&quot;Cell type&quot;) +
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;)) + 
  theme_light() + scale_y_break(c(80, 120),  ticklabels = c(124))</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-69-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>  # scale_y_break(c(60, 185),  ticklabels = c(186))


stressed_table %&gt;% 
  dplyr::select(Var1, Var2, Var3, Var4, fraction) %&gt;%
  pivot_wider(names_from = Var3, values_from = fraction) %&gt;%
  mutate(control10 =  na_if(control10, 0)) %&gt;%
  mutate(change21_10=(stim21pct-control10)/control10) %&gt;%
  replace_na(list(change1_10=0)) %&gt;%
  filter(Var1 != &quot;double_stressed&quot;)  %&gt;%
  filter(Var1 != &quot;unstressed&quot;) %&gt;%
  filter(Var1 != &quot;hypoxia_stressed&quot;) %&gt;%
  ggplot(aes(x=reorder(Var2, -change21_10), y=change21_10, color=Var1)) +
  geom_point() + 
  coord_flip() + 
  ylab(&quot;Gruffi (mash) stress fraction change (control vs 21%)&quot;) +
  xlab(&quot;Cell type&quot;) +
  scale_color_manual(values = c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;)) + 
  theme_light()</code></pre>
<pre><code>Warning: Removed 1 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-69-2.png" width="672" style="display: block; margin: auto;" /></p>
<div id="cell-type-markers-in-responsive-cells" class="section level3">
<h3>Cell type markers in responsive cells</h3>
<p>Treatment-responsive cells do not represent distinct cell types. As
an illustration of this, I looked at a few markers of radial glia,
immature neurons, intermediate progenitors, and dividing cells
(comprised of radial glia and intermediate progenitors) in order to
confirm that their distinct cell type markers are not lost after
treatment.</p>
<pre class="r"><code>colors=c(&quot;unstressed&quot;= &quot;#abd9e9&quot;, &quot;hypoxia_stressed&quot; = &quot;#d7191c&quot;, &quot;hyperoxia_stressed&quot;= &quot;#fdae61&quot;, &quot;double_stressed&quot; = &quot;purple&quot;)
ip_subset &lt;- subset(harmony.batchandindividual.sct, subset = combined.annotation.coarse.harmony==&quot;IP&quot;)
ip_subset$gruffi_label_mash &lt;- factor(ip_subset$gruffi_label_mash, levels = c(&quot;unstressed&quot;, &quot;hypoxia_stressed&quot;, &quot;hyperoxia_stressed&quot;, &quot;double_stressed&quot;))

VlnPlot(ip_subset, features = &quot;EOMES&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-70-1.png" width="672" style="display: block; margin: auto;" />
For radial glia:</p>
<pre class="r"><code>rg_subset &lt;- subset(harmony.batchandindividual.sct, subset = combined.annotation.coarse.harmony==&quot;RG&quot; &amp; gruffi_label != &quot;double_stressed&quot;  &amp; gruffi_label_mash != &quot;double_stressed&quot;)

rg_subset$gruffi_label_mash &lt;- factor(rg_subset$gruffi_label_mash, levels = c(&quot;unstressed&quot;, &quot;hypoxia_stressed&quot;, &quot;hyperoxia_stressed&quot;, &quot;double_stressed&quot;))

VlnPlot(rg_subset, features = &quot;LIFR&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<pre><code>Warning: Removed 1 rows containing non-finite values (`stat_ydensity()`).</code></pre>
<pre><code>Warning: Removed 1 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-71-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(rg_subset, features = &quot;SLC1A3&quot;, group.by = &quot;gruffi_label_mash&quot;, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-71-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(rg_subset, features = &quot;PDGFD&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<pre><code>Warning: Removed 1 rows containing non-finite values (`stat_ydensity()`).
Removed 1 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-71-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(rg_subset, features = &quot;GLI3&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<pre><code>Warning: Removed 1 rows containing non-finite values (`stat_ydensity()`).
Removed 1 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-71-4.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(rg_subset, features = &quot;PAX6&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-71-5.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(rg_subset, features = &quot;SOX2&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-71-6.png" width="672" style="display: block; margin: auto;" />
For dividing cells:</p>
<pre class="r"><code>cycling_subset &lt;- subset(harmony.batchandindividual.sct, subset = combined.annotation.fine.harmony==&quot;RGcycling&quot; &amp; gruffi_label != &quot;double_stressed&quot;  &amp; gruffi_label_mash != &quot;double_stressed&quot;)
cycling_subset$gruffi_label_mash &lt;- factor(cycling_subset$gruffi_label_mash, levels = c(&quot;unstressed&quot;, &quot;hypoxia_stressed&quot;, &quot;hyperoxia_stressed&quot;, &quot;double_stressed&quot;))

VlnPlot(cycling_subset, features = &quot;TOP2A&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=4, cols=colors) + NoLegend()</code></pre>
<pre><code>Warning: Removed 1 rows containing non-finite values (`stat_ydensity()`).</code></pre>
<pre><code>Warning: Removed 1 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-72-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(cycling_subset, features = &quot;CENPF&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=4, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-72-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(cycling_subset, features = &quot;MKI67&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-72-3.png" width="672" style="display: block; margin: auto;" />
Finally, immature neurons:</p>
<pre class="r"><code>immature_subset &lt;- subset(harmony.batchandindividual.sct, subset = combined.annotation.coarse.harmony==&quot;Immature&quot; &amp; gruffi_label != &quot;double_stressed&quot;  &amp; gruffi_label_mash != &quot;double_stressed&quot;)
immature_subset$gruffi_label_mash &lt;- factor(immature_subset$gruffi_label_mash, levels = c(&quot;unstressed&quot;, &quot;hypoxia_stressed&quot;, &quot;hyperoxia_stressed&quot;, &quot;double_stressed&quot;))

VlnPlot(immature_subset, features = &quot;BCL11B&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<pre><code>Warning: Removed 1 rows containing non-finite values (`stat_ydensity()`).</code></pre>
<pre><code>Warning: Removed 1 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-73-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(immature_subset, features = &quot;MAP2&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<pre><code>Warning: Removed 61 rows containing non-finite values (`stat_ydensity()`).</code></pre>
<pre><code>Warning: Removed 61 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-73-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>VlnPlot(immature_subset, features = &quot;SLA&quot;, group.by = &quot;gruffi_label_mash&quot;, y.max=3, cols=colors) + NoLegend()</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-73-3.png" width="672" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="de-with-gruffi-flagged-cells-censored" class="section level2">
<h2>DE with Gruffi-flagged cells censored</h2>
<pre class="r"><code>harmony.batchandindividual.sct.censored &lt;- subset(harmony.batchandindividual.sct, subset = gruffi_label_mash==&quot;unstressed&quot;)</code></pre>
<p>Now filter to “high quality” cells and pseudobulk. This time,
however, don’t use the cell type mapping threshold, as this penalizes
“ambiguous” cell types, which makes sense for QTL mapping but not so
much for the DE here. Note that this does not have a treatment bias,
thankfully.</p>
<pre class="r"><code>subset_seurat_censored &lt;- subset(harmony.batchandindividual.sct.censored, subset = vireo.prob.singlet &gt; 0.95 &amp; nCount_RNA&lt;20000 &amp; nCount_RNA&gt;2500 &amp; treatment != &quot;control21&quot;)

subset_seurat &lt;- subset(harmony.batchandindividual.sct, subset = vireo.prob.singlet &gt; 0.95 &amp; nCount_RNA&lt;20000 &amp; nCount_RNA&gt;2500 &amp; treatment != &quot;control21&quot; )</code></pre>
<p>We originally used with:</p>
<pre class="r"><code>table(subset_seurat$treatment)</code></pre>
<pre><code>
control10  stim1pct stim21pct 
    52671     57788     60382 </code></pre>
<p>And now have</p>
<pre class="r"><code>table(subset_seurat_censored$treatment)</code></pre>
<pre><code>
control10  stim1pct stim21pct 
    47817     39629     54676 </code></pre>
<p>control10 stim1pct stim21pct 47817 39629 56173</p>
<p>This censors about 9% of the control cells, 31% of the hypoxia cells,
and 7% of the hyperoxia cells, about 16% of the total dataset.</p>
<pre class="r"><code>pseudo_fine_quality_censored &lt;- generate.pseudobulk(subset_seurat_censored, labels = c(&quot;combined.annotation.fine.harmony&quot;, &quot;treatment&quot;, &quot;vireo.individual&quot;, &quot;batch&quot;))
saveRDS(pseudo_fine_quality_censored, file = &quot;output/pseudo_fine_quality_filtered_de_censored_20240802.RDS&quot;)</code></pre>
<pre class="r"><code>pseudo_fine_quality_censored &lt;- readRDS(file = &quot;output/pseudo_fine_quality_filtered_de_censored_20240802.RDS&quot;)
pseudo_fine_quality_de_censored &lt;- filter.pseudobulk(pseudo_fine_quality_censored, threshold = 20)</code></pre>
<pre class="r"><code>pseudo_fine_quality_de_censored$counts &lt;- pseudo_fine_quality_de_censored$counts[,-c(which(pseudo_fine_quality_de_censored$meta$combined.annotation.fine.harmony==&quot;Oligo&quot;))]
pseudo_fine_quality_de_censored$meta &lt;- pseudo_fine_quality_de_censored$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;Oligo&quot;)

# pseudo_fine_quality_de_censored$counts &lt;- pseudo_fine_quality_de_censored$counts[,-c(which(pseudo_fine_quality_de_censored$meta$combined.annotation.fine.harmony==&quot;MidbrainDA&quot;))]
# pseudo_fine_quality_de_censored$meta &lt;- pseudo_fine_quality_de_censored$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;MidbrainDA&quot;)

pseudo_fine_quality_de_censored$counts &lt;- pseudo_fine_quality_de_censored$counts[,-c(which(pseudo_fine_quality_de_censored$meta$combined.annotation.fine.harmony==&quot;VLMC&quot;))]
pseudo_fine_quality_de_censored$meta &lt;- pseudo_fine_quality_de_censored$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;VLMC&quot;)

de_results_combinedfine_filtered_censored &lt;- de_genes_pseudoinput(pseudo_input = pseudo_fine_quality_de_censored, classification = &quot;combined.annotation.fine.harmony&quot;, model_formula = model_formula, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)

saveRDS(de_results_combinedfine_filtered_censored, file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_censored_20240802.RDS&quot;)</code></pre>
<p>Of course, downsampling the data will result in fewer DE genes, so I
compare this to a random downsampling of the same proportions from the
different conditions:</p>
<pre class="r"><code>censoring_stats_hypoxia &lt;- subset_seurat@meta.data %&gt;% 
  filter(gruffi_label_mash != &quot;hyperoxia_stressed&quot;) %&gt;% 
  group_by(combined.annotation.fine.harmony) %&gt;% 
  summarize(fraction=sum(gruffi_label_mash==&quot;hypoxia_stressed&quot;)/n()) 

censoring_stats_hyperoxia &lt;- subset_seurat@meta.data %&gt;% 
  filter(gruffi_label_mash != &quot;hypoxia_stressed&quot;) %&gt;% 
  group_by(combined.annotation.fine.harmony) %&gt;% 
  summarize(fraction=sum(gruffi_label_mash==&quot;hyperoxia_stressed&quot;)/n()) </code></pre>
<pre class="r"><code>subset_seurat$selection &lt;- NA

for (celltype in censoring_stats_hypoxia$combined.annotation.fine.harmony){
  indices_hypoxia &lt;- sample(x = which(subset_seurat$combined.annotation.fine.harmony==celltype), size = round(deframe(censoring_stats_hypoxia)[celltype]*length(which(subset_seurat$combined.annotation.fine.harmony==celltype))), replace = FALSE)
  
  indices_hyperoxia &lt;- sample(x = which(subset_seurat$combined.annotation.fine.harmony==celltype), size = round(deframe(censoring_stats_hyperoxia)[celltype]*length(which(subset_seurat$combined.annotation.fine.harmony==celltype))), replace = FALSE)
  
  subset_seurat$selection[unique(c(indices_hypoxia, indices_hyperoxia))] &lt;- &quot;random_censored&quot;
  
  rm(indices_hypoxia, indices_hyperoxia)
}

subset_seurat_censored_random &lt;- subset(subset_seurat, subset = selection == &quot;random_censored&quot;, invert=TRUE)

pseudo_fine_quality_censored_random &lt;- generate.pseudobulk(subset_seurat_censored_random, labels = c(&quot;combined.annotation.fine.harmony&quot;, &quot;treatment&quot;, &quot;vireo.individual&quot;, &quot;batch&quot;))
saveRDS(pseudo_fine_quality_censored_random, file = &quot;output/pseudo_fine_quality_filtered_de_randomly_censored_20240802.RDS&quot;)</code></pre>
<pre class="r"><code>pseudo_fine_quality_censored_random &lt;- readRDS(file = &quot;output/pseudo_fine_quality_filtered_de_randomly_censored_20240802.RDS&quot;)
pseudo_fine_quality_de_censored_random &lt;- filter.pseudobulk(pseudo_fine_quality_censored_random, threshold = 20)</code></pre>
<pre class="r"><code>pseudo_fine_quality_de_censored_random$counts &lt;- pseudo_fine_quality_de_censored_random$counts[,-c(which(pseudo_fine_quality_de_censored_random$meta$combined.annotation.fine.harmony==&quot;Oligo&quot;))]
pseudo_fine_quality_de_censored_random$meta &lt;- pseudo_fine_quality_de_censored_random$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;Oligo&quot;)

pseudo_fine_quality_de_censored_random$counts &lt;- pseudo_fine_quality_de_censored_random$counts[,-c(which(pseudo_fine_quality_de_censored_random$meta$combined.annotation.fine.harmony==&quot;VLMC&quot;))]
pseudo_fine_quality_de_censored_random$meta &lt;- pseudo_fine_quality_de_censored_random$meta %&gt;% filter(combined.annotation.fine.harmony != &quot;VLMC&quot;)

de_results_combinedfine_filtered_censored_random &lt;- de_genes_pseudoinput(pseudo_input = pseudo_fine_quality_de_censored_random, classification = &quot;combined.annotation.fine.harmony&quot;, model_formula = model_formula, maineffect = &quot;treatment&quot;, min.count = 5, min.prop=0.7, min.total.count = 10)

saveRDS(de_results_combinedfine_filtered_censored_random, file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_random_censored_20240802.RDS&quot;)</code></pre>
<pre class="r"><code>de_results_combinedfine_filtered_censored_random &lt;- readRDS(file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_random_censored_20240802.RDS&quot;)

de_results_combinedfine_filtered_censored &lt;- readRDS(file = &quot;/project2/gilad/umans/oxygen_eqtl/output/de_results_combinedfine_filtered_reharmonize_censored_20240802.RDS&quot;)</code></pre>
<p>Summarize the results, looking at the change between the randomly
censored and stress-censored:</p>
<pre class="r"><code># here, the &quot;uncensored&quot; are the randomly censored, in order to match number of individuals

de.summary.fine.censored.change.random &lt;-  matrix(0, nrow = length(names(de_results_combinedfine_filtered_censored_random)), ncol =10)
colnames(de.summary.fine.censored.change.random) &lt;-c(&quot;hypoxia_random_censored&quot;, &quot;hyperoxia_random_censored&quot;, &quot;hypoxia_censored&quot;, &quot;hyperoxia_censored&quot;, &quot;nindiv_hypoxia&quot;, &quot;nindiv_hyperoxia&quot;, &quot;hypoxia_mineffect_random_censored&quot;, &quot;hyperoxia_mineffect_random_censored&quot;, &quot;hypoxia_mineffect_censored&quot;, &quot;hyperoxia_mineffect_censored&quot;)
rownames(de.summary.fine.censored.change.random) &lt;- names(de_results_combinedfine_filtered_censored_random)


for (cell in names(de_results_combinedfine_filtered_censored_random)){
    de.summary.fine.censored.change.random[cell, 1] &lt;- sum(topTable(de_results_combinedfine_filtered_censored_random[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
  de.summary.fine.censored.change.random[cell, 2] &lt;- sum(topTable(de_results_combinedfine_filtered_censored_random[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
    de.summary.fine.censored.change.random[cell, 3] &lt;- sum(topTable(de_results_combinedfine_filtered_censored[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
  de.summary.fine.censored.change.random[cell, 4] &lt;- sum(topTable(de_results_combinedfine_filtered_censored[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf)$adj.P.Val &lt; 0.05)
  

    de.summary.fine.censored.change.random[cell, 5] &lt;- pseudo_fine_quality_de_censored$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim1pct&quot;)) %&gt;% pull(vireo.individual) %&gt;% unique() %&gt;% length()
    de.summary.fine.censored.change.random[cell, 6] &lt;- pseudo_fine_quality_de_censored$meta %&gt;% filter(combined.annotation.fine.harmony==cell) %&gt;% dplyr::filter(treatment %in% c(&quot;control10&quot;, &quot;stim21pct&quot;)) %&gt;% pull(vireo.individual) %&gt;% unique() %&gt;% length()
    de.summary.fine.censored.change.random[cell, 7] &lt;- topTable(de_results_combinedfine_filtered_censored_random[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow() 
  de.summary.fine.censored.change.random[cell, 8] &lt;- topTable(de_results_combinedfine_filtered_censored_random[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow()

    de.summary.fine.censored.change.random[cell, 9] &lt;- topTable(de_results_combinedfine_filtered_censored[[cell]], coef=&quot;treatmentstim1pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow() 
  de.summary.fine.censored.change.random[cell, 10] &lt;- topTable(de_results_combinedfine_filtered_censored[[cell]], coef=&quot;treatmentstim21pct&quot;, number = Inf) %&gt;% filter(adj.P.Val &lt; 0.05) %&gt;% filter(abs(logFC)&gt;0.58) %&gt;% nrow()

}

de.summary.fine.censored.change.random &lt;- de.summary.fine.censored.change.random %&gt;% as.data.frame() %&gt;% arrange(nindiv_hypoxia) %&gt;% rownames_to_column(&quot;celltype&quot;)</code></pre>
<pre class="r"><code>de.summary.fine.censored.change.random %&gt;% 
  left_join(y = censoring_stats_hypoxia, by=join_by(celltype==combined.annotation.fine.harmony)) %&gt;% 
  ggplot(mapping = aes(x=fraction, y=1-(hypoxia_mineffect_censored/hypoxia_mineffect_random_censored), label=celltype)) +
  geom_point() + geom_text_repel() + 
  theme_light() + 
  xlab(&quot;Censored fraction&quot;) + 
  ylab(&quot;1-(stress-censored DE genes/randomly censored DE genes)&quot;) + geom_abline(slope = 1, intercept = 0, linetype=2) +
  ggtitle(&quot;hypoxia &gt;1.5fold&quot;)</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-87-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="cell-positions-within-organoids" class="section level2">
<h2>Cell positions within organoids</h2>
<p>Here, I import measurement information from QuPath, classify cells as
positive for stained markers (thresholds were identified iteratively by
comparisons using QuPath), and combine results from different staining
sets.</p>
<p>For samples stained for HOPX/KI67/S100b:</p>
<pre class="r"><code>annotations_hopx &lt;- read_delim(file =  &quot;Active Processing/HOPX_MKI67_S100B/QuPath_output/Stardist_measurements_HOPX_MKI67_S100B_annotations.csv&quot;) %&gt;% 
  filter(Name != &quot;Other&quot;) %&gt;% 
  dplyr::select(Image, `Object ID`, Name, `Area µm^2`, `Perimeter µm`)
hopx1 &lt;- read_delim(file =  &quot;Active Processing/HOPX_MKI67_S100B/QuPath_output/Stardist_measurements_HOPX_MKI67_S100B_detections1.csv&quot;)
hopx2 &lt;- read_delim(file =  &quot;Active Processing/HOPX_MKI67_S100B/QuPath_output/Stardist_measurements_HOPX_MKI67_S100B_detections2.csv&quot;)
hopx3 &lt;- read_delim(file =  &quot;Active Processing/HOPX_MKI67_S100B/QuPath_output/Stardist_measurements_HOPX_MKI67_S100B_detections3.csv&quot;)

detections_hopx &lt;- bind_rows(hopx1, hopx2, hopx3) %&gt;% left_join(annotations_hopx, by=c(&quot;Parent&quot; = &quot;Name&quot;))
rm(hopx1, hopx2, hopx3)

detections_hopx_plotting &lt;- detections_hopx %&gt;% 
  replace_na(list(`MCherry: Nucleus: Mean`=0, `TRITC: Nucleus: Mean`=0)) %&gt;% ##DEAL WITH NAs for &gt;
  group_by(Parent) %&gt;% 
  mutate(HOPX= `FITC: Nucleus: Mean` &gt;  mean(`FITC: Nucleus: Mean`) + 2*sd(`FITC: Nucleus: Mean`)) %&gt;% 
  mutate(MKI67 = (`MCherry: Nucleus: Mean` &gt; mean(`MCherry: Nucleus: Mean`) + 1.5*sd(`MCherry: Nucleus: Mean`)) | (`TRITC: Nucleus: Mean` &gt; mean(`TRITC: Nucleus: Mean`) + 1.5*sd(`TRITC: Nucleus: Mean`))) %&gt;% 
  mutate(S100B = `Cy5: Nucleus: Mean` &gt; mean(`Cy5: Nucleus: Mean`) + 2*sd(`Cy5: Nucleus: Mean`)) %&gt;% 
  ungroup() %&gt;% 
  mutate(scaled_distance= `Distance to annotation with Other µm`/sqrt(`Area µm^2`)) 

df &lt;- detections_hopx_plotting %&gt;% select(HOPX, MKI67, S100B)
detections_hopx_plotting$cell_type &lt;-apply(df, 1, function(x) paste(names(df)[x], collapse = &quot;,&quot;))

rm(df)</code></pre>
<p>For samples stained for EOMES/CTIP2/SATB2:</p>
<pre class="r"><code>annotations_eomes &lt;- read_delim(file =  &quot;Active Processing/EOMES_CTIP2_SATB2/QuPath_output/Stardist_measurements_EOMES_CTIP2_SATB2_annotations.csv&quot;) %&gt;% 
  filter(Name != &quot;Other&quot;) %&gt;% 
  dplyr::select(Image, `Object ID`, Name, `Area µm^2`, `Perimeter µm`)

eomes1 &lt;- read_delim(file =  &quot;Active Processing/EOMES_CTIP2_SATB2/QuPath_output/Stardist_measurements_EOMES_CTIP2_SATB2_detections1.csv&quot;) 
eomes2 &lt;- read_delim(file =  &quot;Active Processing/EOMES_CTIP2_SATB2/QuPath_output/Stardist_measurements_EOMES_CTIP2_SATB2_detections2.csv&quot;) 
eomes3 &lt;- read_delim(file =  &quot;Active Processing/EOMES_CTIP2_SATB2/QuPath_output/Stardist_measurements_EOMES_CTIP2_SATB2_detections3.csv&quot;) 

detections_eomes &lt;- bind_rows(eomes1, eomes2, eomes3) %&gt;% left_join(annotations_eomes, by=c(&quot;Parent&quot; = &quot;Name&quot;))

rm(eomes1, eomes2, eomes3)

detections_eomes_plotting &lt;- detections_eomes %&gt;% 
  group_by(Parent) %&gt;% 
  mutate(EOMES= `FITC: Nucleus: Mean` &gt;  mean(`FITC: Nucleus: Mean`) + 1.5*sd(`FITC: Nucleus: Mean`)) %&gt;% 
  mutate(SATB2 = `TRITC: Nucleus: Mean` &gt; mean(`TRITC: Nucleus: Mean`) + 1.5*sd(`TRITC: Nucleus: Mean`) ) %&gt;% 
  mutate(CTIP2 = `Cy5: Nucleus: Mean` &gt; max(mean(`Cy5: Nucleus: Mean`) + 1*sd(`Cy5: Nucleus: Mean`), 1300)) %&gt;% 
  ungroup() %&gt;% 
  mutate(scaled_distance= `Distance to annotation with Other µm`/sqrt(`Area µm^2`)) 

df &lt;- detections_eomes_plotting %&gt;% select(EOMES, SATB2, CTIP2)
detections_eomes_plotting$cell_type &lt;-apply(df, 1, function(x) paste(names(df)[x], collapse = &quot;,&quot;))

rm(df)</code></pre>
<p>For samples stained for RELN/GABA/CTIP2:</p>
<pre class="r"><code>annotations_reln &lt;- read_delim(file =  &quot;Active Processing/RELN_GABA_CTIP2/QuPath_output/Stardist_measurements_RELN_GABA_CTIP2_annotations.csv&quot;) %&gt;% 
  filter(Name != &quot;Other&quot;) %&gt;% 
  dplyr::select(Image, `Object ID`, Name, `Area µm^2`, `Perimeter µm`)

reln1 &lt;- read_delim(file =  &quot;Active Processing/RELN_GABA_CTIP2/QuPath_output/Stardist_measurements_RELN_GABA_CTIP2_detections1.csv&quot;) 
reln2 &lt;- read_delim(file =  &quot;Active Processing/RELN_GABA_CTIP2/QuPath_output/Stardist_measurements_RELN_GABA_CTIP2_detections2.csv&quot;) 

detections_reln &lt;- bind_rows(reln1, reln2) %&gt;% left_join(annotations_reln, by=c(&quot;Parent&quot; = &quot;Name&quot;))

rm(reln1, reln2)

detections_reln_plotting &lt;- detections_reln %&gt;% 
  group_by(Parent) %&gt;% 
  mutate(RELN= `FITC: Nucleus: Mean` &gt;  max(mean(`FITC: Nucleus: Mean`) + 2*sd(`FITC: Nucleus: Mean`), 1100)) %&gt;% 
  mutate(GABA = `MCherry: Nucleus: Mean` &gt; max(mean(`MCherry: Nucleus: Mean`) + 2*sd(`MCherry: Nucleus: Mean`), 1000)) %&gt;% 
  mutate(CTIP2 = `Cy5: Nucleus: Mean` &gt; mean(`Cy5: Nucleus: Mean`) + 1.5*sd(`Cy5: Nucleus: Mean`)) %&gt;% 
  ungroup() %&gt;% 
  mutate(scaled_distance= `Distance to annotation with Other µm`/sqrt(`Area µm^2`)) 

df &lt;- detections_reln_plotting %&gt;% select(RELN, GABA, CTIP2)
detections_reln_plotting$cell_type &lt;-apply(df, 1, function(x) paste(names(df)[x], collapse = &quot;,&quot;))

detections_reln_plotting_singlesection &lt;- detections_reln_plotting %&gt;% group_by(cell_line, BP) %&gt;% 
  filter(`Area µm^2`==max(`Area µm^2`)) %&gt;% ungroup()
rm(df)</code></pre>
<p>For samples stained for SOX2/NES/S100B:</p>
<pre class="r"><code>annotations_sox &lt;- read_delim(file =  &quot;Active Processing/SOX2_NES_S100B/QuPath_output/Stardist_measurements_SOX2_NES_S100B_annotations.csv&quot;) %&gt;% 
  filter(Name != &quot;Other&quot;) %&gt;% 
  dplyr::select(Image, `Object ID`, Name, `Area µm^2`, `Perimeter µm`)

sox1 &lt;- read_delim(file =  &quot;Active Processing/SOX2_NES_S100B/QuPath_output/Stardist_measurements_SOX2_NES_S100B_detections1.csv&quot;) 
sox2 &lt;- read_delim(file =  &quot;Active Processing/SOX2_NES_S100B/QuPath_output/Stardist_measurements_SOX2_NES_S100B_detections2.csv&quot;) 
sox3 &lt;- read_delim(file =  &quot;Active Processing/SOX2_NES_S100B/QuPath_output/Stardist_measurements_SOX2_NES_S100B_detections3.csv&quot;) 
sox4 &lt;- read_delim(file =  &quot;Active Processing/SOX2_NES_S100B/QuPath_output/Stardist_measurements_SOX2_NES_S100B_detections4.csv&quot;) 

detections_sox &lt;- bind_rows(sox1, sox2, sox3, sox4) %&gt;% left_join(annotations_sox, by=c(&quot;Parent&quot; = &quot;Name&quot;))

rm(sox1, sox2, sox3, sox4)

detections_sox_plotting &lt;- detections_sox %&gt;% 
  group_by(Parent) %&gt;% 
  mutate(SOX2= `FITC: Nucleus: Mean` &gt;  max(mean(`FITC: Nucleus: Mean`) + 1*sd(`FITC: Nucleus: Mean`), 800)) %&gt;% 
  mutate(NES= `TRITC: Nucleus: Mean` &gt; mean(`TRITC: Nucleus: Mean`) + 1*sd(`TRITC: Nucleus: Mean`)) %&gt;% 
  mutate(S100B = `Cy5: Nucleus: Mean` &gt; mean(`Cy5: Nucleus: Mean`) + 1*sd(`Cy5: Nucleus: Mean`)) %&gt;% 
  ungroup() %&gt;% 
  mutate(scaled_distance= `Distance to annotation with Other µm`/sqrt(`Area µm^2`)) 

df &lt;- detections_sox_plotting %&gt;% select(SOX2, NES, S100B)
detections_sox_plotting$cell_type &lt;-apply(df, 1, function(x) paste(names(df)[x], collapse = &quot;,&quot;))


detections_sox_plotting_singlesection &lt;- detections_sox_plotting %&gt;% group_by(cell_line, BP) %&gt;% 
  filter(`Area µm^2`==max(`Area µm^2`)) %&gt;% ungroup()

rm(df)</code></pre>
<p>For samples stained for GFAP:</p>
<pre class="r"><code>annotations_gfap &lt;- read_delim(file =  &quot;Active Processing/MGP_GFAP/QuPath_output/Stardist_measurements_MGP_GFAP_annotations.csv&quot;) %&gt;% 
  filter(Name != &quot;Other&quot;) %&gt;% 
  dplyr::select(Image, `Object ID`, Name, `Area µm^2`, `Perimeter µm`)

gfap1 &lt;- read_delim(file =  &quot;Active Processing/MGP_GFAP/QuPath_output/Stardist_measurements_MGP_GFAP_detections1.csv&quot;) 
gfap2 &lt;- read_delim(file =  &quot;Active Processing/MGP_GFAP/QuPath_output/Stardist_measurements_MGP_GFAP_detections2.csv&quot;) 

detections_gfap &lt;- bind_rows(gfap1, gfap2) %&gt;% left_join(annotations_gfap, by=c(&quot;Parent&quot; = &quot;Name&quot;))

rm(gfap1, gfap2)

detections_gfap_plotting &lt;- detections_gfap %&gt;% 
  group_by(Parent) %&gt;% 
  mutate(GFAP = `Cy5: Nucleus: Mean` &gt; mean(`Cy5: Nucleus: Mean`) + 1.5*sd(`Cy5: Nucleus: Mean`)) %&gt;% 
  ungroup() %&gt;% 
  mutate(scaled_distance= `Distance to annotation with Other µm`/sqrt(`Area µm^2`)) 

df &lt;- detections_gfap_plotting %&gt;% select(GFAP)
detections_gfap_plotting$cell_type &lt;-apply(df, 1, function(x) paste(names(df)[x], collapse = &quot;,&quot;))

detections_gfap_plotting_singlesection &lt;- detections_gfap_plotting %&gt;% group_by(cell_line, BP) %&gt;% 
  filter(`Area µm^2`==max(`Area µm^2`)) %&gt;% ungroup()

rm(df)</code></pre>
<p>Combine all of the data:</p>
<pre class="r"><code>combined_plotting_singlesection &lt;- bind_rows(detections_reln_plotting_singlesection %&gt;% select(cell_line, Parent, BP, scaled_distance, `Distance to annotation with Other µm`, cell_type),
                                             detections_sox_plotting_singlesection %&gt;% select(cell_line, Parent, BP, scaled_distance, `Distance to annotation with Other µm`, cell_type),
                                             detections_reln_plotting_singlesection %&gt;% select(cell_line, Parent, BP, scaled_distance, `Distance to annotation with Other µm`, cell_type),
                                             detections_gfap_plotting_singlesection %&gt;% select(cell_line, Parent, BP, scaled_distance, `Distance to annotation with Other µm`, cell_type),
                                             detections_eomes_plotting_singlesection %&gt;% select(cell_line, Parent, BP, scaled_distance, `Distance to annotation with Other µm`, cell_type),
                                             detections_hopx_plotting_singlesection %&gt;% select(cell_line, Parent, BP, scaled_distance, `Distance to annotation with Other µm`, cell_type)) %&gt;% 
  mutate_at(&quot;cell_type&quot;, ~na_if(., &quot;&quot;)) %&gt;% 
  mutate(cell_type=replace_na(cell_type, &quot;unlabeled&quot;))</code></pre>
<p>Cell types were classified based on the stained markers in
combination within a given staining set, as not all cells can be
distinguished in each context (e.g., CTIP2+ neurons can only be
distinguished from SATB2+/CTIP2+ neurons when both antibodies are
present).</p>
<pre class="r"><code>combined_plotting_singlesection$cell_type_pooled_revised &lt;- &quot;unlabeled&quot;

combined_plotting_singlesection &lt;- combined_plotting_singlesection %&gt;% mutate(cell_type_pooled_revised =case_when(
  str_detect(Parent, &quot;CTIP2_SATB2&quot;) &amp; cell_type==&quot;CTIP2&quot; ~ &quot;Excitatory-early&quot;,
  str_detect(Parent, &quot;CTIP2_SATB2&quot;) &amp; cell_type==&quot;SATB2&quot; ~ &quot;Excitatory-late&quot;,
  str_detect(Parent, &quot;CTIP2_SATB2&quot;) &amp; cell_type==&quot;SATB2,CTIP2&quot; ~ &quot;Excitatory-late&quot;,
  str_detect(Parent, &quot;CTIP2_SATB2&quot;) &amp; cell_type==&quot;EOMES&quot; ~ &quot;IP&quot;,
  str_detect(Parent, &quot;HOPX&quot;) &amp; cell_type==&quot;MKI67&quot; ~ &quot;DividingProgenitors&quot;,
  str_detect(Parent, &quot;HOPX&quot;) &amp; cell_type==&quot;HOPX&quot; ~ &quot;RadialGlia&quot;,
  str_detect(Parent, &quot;HOPX&quot;) &amp; cell_type==&quot;HOPX,MKI67&quot; ~ &quot;RadialGlia&quot;,
  str_detect(Parent, &quot;HOPX&quot;) &amp; cell_type==&quot;S100B&quot; ~ &quot;Glia&quot;,
  str_detect(Parent, &quot;RELN&quot;) &amp; cell_type==&quot;RELN&quot; ~ &quot;Cajal&quot;,
  str_detect(Parent, &quot;RELN&quot;) &amp; cell_type==&quot;RELN,GABA&quot; ~ &quot;Inhibitory&quot;,
  str_detect(Parent, &quot;RELN&quot;) &amp; cell_type==&quot;GABA&quot; ~ &quot;Inhibitory&quot;,
  str_detect(Parent, &quot;RELN&quot;) &amp; cell_type==&quot;GABA,CTIP2&quot; ~ &quot;Inhibitory&quot;,  #we ignore the large number of CTIP2+/GABA- cells here because we can&#39;t distinguish them from the substantial number of CTIP2+/SATB2+ (ie, &quot;mature&quot;) excitatory neurons
  str_detect(Parent, &quot;SOX2_NES_S100b&quot;) &amp; cell_type==&quot;SOX2,NES,S100B&quot; ~ &quot;Glia&quot;,
  str_detect(Parent, &quot;SOX2_NES_S100b&quot;) &amp; cell_type==&quot;S100B&quot; ~ &quot;Glia&quot;, #while this marker is not perfect in many in vivo contexts, the correspondence is clear in our RNAseq data
  # str_detect(Parent, &quot;SOX2_NES_S100b&quot;) &amp; cell_type==&quot;SOX2,S100B&quot; ~ &quot;RadialGlia&quot;,
  str_detect(Parent, &quot;SOX2_NES_S100b&quot;) &amp; cell_type==&quot;SOX2,NES&quot; ~ &quot;OtherProgenitor&quot;, #NES should mark Glia, Floorplate, RG, Cycling Progenitors; S100B should be (RNA) specific for Glia; SOX2 hits choroid/cycling progenitors/floorplate/glia/IP/RG
  str_detect(Parent, &quot;GFAP&quot;) &amp; cell_type==&quot;GFAP&quot; ~ &quot;Glia&quot;, #again, while this marker is not perfect in many in vivo contexts, the correspondence is clear in our RNAseq data
  .default=&quot;unlabeled&quot;))</code></pre>
<p>For plotting purposes, load the processed data object:</p>
<pre class="r"><code>combined_plotting_singlesection &lt;- readRDS(file = &quot;output/combined_plotting_singlesection_upload.RDS&quot;)</code></pre>
<p>Next, plot the distributions of cell types here. Note that, as this
is intended as a comparison for responsive cell types as annotated in
our single-cell RNAseq data, we exclude cells (e.g., “other
progenitors”) that do not have a specific correspondence in our
transcriptomic data:</p>
<pre class="r"><code>positions &lt;- c( #&quot;DividingProgenitors&quot;,
               &quot;IP&quot;,
               &quot;Excitatory-early&quot;,
               &quot;Excitatory-late&quot;,
               &quot;RadialGlia&quot;,
               &quot;Cajal&quot;,
               &quot;Inhibitory&quot;,
               &quot;Glia&quot;,
               &quot;unlabeled&quot;
              )

color_set &lt;- c(&quot;unlabeled&quot;= &quot;black&quot;,
               &quot;DividingProgenitors&quot;=&quot;#882255&quot;,
               &quot;RadialGlia&quot;=&quot;#8DD3C7&quot;, 
               &quot;Cajal&quot;=&quot;#80B1D3&quot;,
               &quot;IP&quot;=&quot;#BEBADA&quot;, 
               &quot;Excitatory-early&quot;=&quot;#FB8072&quot;,
               &quot;Excitatory-late&quot;=&quot;#fc9016&quot;,
               &quot;Excitatory&quot;=&quot;#88CCEE&quot;,
               &quot;Inhibitory&quot;=&quot;#AFAFAF&quot;, 
               &quot;Glia&quot;=&quot;#FFFFB3&quot;)


ggplot(combined_plotting_singlesection, aes(x=cell_type_pooled_revised, y=`Distance to annotation with Other µm`, color=cell_type_pooled_revised)) + geom_boxplot() + scale_x_discrete(limits = positions) + 
  ggtitle(&quot;Cell distances, aggregated over individuals&quot;) +
  scale_colour_manual(values = color_set) +
  stat_summary(fun.y = median, 
               geom = &quot;point&quot;,
               aes(group = interaction(Parent, cell_type_pooled_revised)),
               size = 1, show.legend = F, color=&quot;black&quot;) + 
  theme_light() + theme(legend.position=&quot;none&quot;) + coord_flip()</code></pre>
<pre><code>Warning: The `fun.y` argument of `stat_summary()` is deprecated as of ggplot2 3.3.0.
ℹ Please use the `fun` argument instead.
This warning is displayed once every 8 hours.
Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
generated.</code></pre>
<pre><code>Warning: Removed 18710 rows containing missing values (`stat_boxplot()`).</code></pre>
<pre><code>Warning: Removed 18710 rows containing non-finite values (`stat_summary()`).</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-96-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>There are, of course, differences between cell types when all
aggregated together. To compare the differences between individuals to
the differences between cell types, we can use ANOVA, using the mean
values for cells within each sample (ie, individual).</p>
<pre class="r"><code>aov_test &lt;- aov(data ~ cell_type_pooled_revised, data = combined_plotting_singlesection %&gt;% 
                  group_by(Parent, cell_type_pooled_revised) %&gt;% 
                  summarise(data=mean(`Distance to annotation with Other µm`)) %&gt;% 
                  ungroup())</code></pre>
<pre><code>`summarise()` has grouped output by &#39;Parent&#39;. You can override using the
`.groups` argument.
`summarise()` has grouped output by &#39;Parent&#39;. You can override using the
`.groups` argument.</code></pre>
<pre class="r"><code>summary(aov_test)</code></pre>
<pre><code>                         Df Sum Sq Mean Sq F value Pr(&gt;F)
cell_type_pooled_revised  9  64006    7112   0.783  0.632
Residuals                76 690016    9079               </code></pre>
<p>And we can do this with each post-hoc comparison for further
detail:</p>
<pre class="r"><code>library(afex)</code></pre>
<pre><code>Loading required package: lme4</code></pre>
<pre><code>Loading required package: Matrix</code></pre>
<pre><code>
Attaching package: &#39;Matrix&#39;</code></pre>
<pre><code>The following objects are masked from &#39;package:tidyr&#39;:

    expand, pack, unpack</code></pre>
<pre><code>************
Welcome to afex. For support visit: http://afex.singmann.science/</code></pre>
<pre><code>- Functions for ANOVAs: aov_car(), aov_ez(), and aov_4()
- Methods for calculating p-values with mixed(): &#39;S&#39;, &#39;KR&#39;, &#39;LRT&#39;, and &#39;PB&#39;
- &#39;afex_aov&#39; and &#39;mixed&#39; objects can be passed to emmeans() for follow-up tests
- Get and set global package options with: afex_options()
- Set sum-to-zero contrasts globally: set_sum_contrasts()
- For example analyses see: browseVignettes(&quot;afex&quot;)
************</code></pre>
<pre><code>
Attaching package: &#39;afex&#39;</code></pre>
<pre><code>The following object is masked from &#39;package:lme4&#39;:

    lmer</code></pre>
<pre class="r"><code>library(emmeans)
summarized_data &lt;- combined_plotting_singlesection %&gt;% group_by(Parent, cell_type_pooled_revised) %&gt;% summarise(data=mean(`Distance to annotation with Other µm`)) %&gt;% ungroup() %&gt;% mutate(id=row_number())</code></pre>
<pre><code>`summarise()` has grouped output by &#39;Parent&#39;. You can override using the
`.groups` argument.</code></pre>
<pre class="r"><code>aovcar_test &lt;- aov_car(formula = data ~ cell_type_pooled_revised + Error(id), data = summarized_data)</code></pre>
<pre><code>Converting to factor: cell_type_pooled_revised</code></pre>
<pre><code>Contrasts set to contr.sum for the following variables: cell_type_pooled_revised</code></pre>
<pre class="r"><code>pairs(emmeans(aovcar_test, specs = &quot;cell_type_pooled_revised&quot;))</code></pre>
<pre><code> contrast                                 estimate   SE df t.ratio p.value
 Cajal - DividingProgenitors                79.881 61.5 76   1.299  0.9510
 Cajal - (Excitatory-early)                 58.683 61.5 76   0.954  0.9939
 Cajal - (Excitatory-late)                  84.754 61.5 76   1.378  0.9302
 Cajal - Glia                               54.534 53.3 76   1.024  0.9899
 Cajal - IP                                 95.881 61.5 76   1.559  0.8631
 Cajal - Inhibitory                         22.879 67.4 76   0.340  1.0000
 Cajal - OtherProgenitor                   109.040 61.5 76   1.773  0.7497
 Cajal - RadialGlia                         58.060 61.5 76   0.944  0.9944
 Cajal - unlabeled                          34.351 51.2 76   0.671  0.9996
 DividingProgenitors - (Excitatory-early)  -21.198 55.0 76  -0.385  1.0000
 DividingProgenitors - (Excitatory-late)     4.873 55.0 76   0.089  1.0000
 DividingProgenitors - Glia                -25.346 45.6 76  -0.556  0.9999
 DividingProgenitors - IP                   16.001 55.0 76   0.291  1.0000
 DividingProgenitors - Inhibitory          -57.002 61.5 76  -0.927  0.9951
 DividingProgenitors - OtherProgenitor      29.159 55.0 76   0.530  0.9999
 DividingProgenitors - RadialGlia          -21.821 55.0 76  -0.397  1.0000
 DividingProgenitors - unlabeled           -45.530 43.2 76  -1.055  0.9875
 (Excitatory-early) - (Excitatory-late)     26.071 55.0 76   0.474  1.0000
 (Excitatory-early) - Glia                  -4.148 45.6 76  -0.091  1.0000
 (Excitatory-early) - IP                    37.199 55.0 76   0.676  0.9996
 (Excitatory-early) - Inhibitory           -35.804 61.5 76  -0.582  0.9999
 (Excitatory-early) - OtherProgenitor       50.357 55.0 76   0.915  0.9955
 (Excitatory-early) - RadialGlia            -0.623 55.0 76  -0.011  1.0000
 (Excitatory-early) - unlabeled            -24.332 43.2 76  -0.564  0.9999
 (Excitatory-late) - Glia                  -30.219 45.6 76  -0.663  0.9996
 (Excitatory-late) - IP                     11.128 55.0 76   0.202  1.0000
 (Excitatory-late) - Inhibitory            -61.875 61.5 76  -1.006  0.9911
 (Excitatory-late) - OtherProgenitor        24.286 55.0 76   0.441  1.0000
 (Excitatory-late) - RadialGlia            -26.694 55.0 76  -0.485  1.0000
 (Excitatory-late) - unlabeled             -50.403 43.2 76  -1.168  0.9750
 Glia - IP                                  41.347 45.6 76   0.906  0.9958
 Glia - Inhibitory                         -31.656 53.3 76  -0.594  0.9999
 Glia - OtherProgenitor                     54.505 45.6 76   1.195  0.9710
 Glia - RadialGlia                           3.525 45.6 76   0.077  1.0000
 Glia - unlabeled                          -20.184 30.3 76  -0.667  0.9996
 IP - Inhibitory                           -73.003 61.5 76  -1.187  0.9722
 IP - OtherProgenitor                       13.158 55.0 76   0.239  1.0000
 IP - RadialGlia                           -37.822 55.0 76  -0.688  0.9995
 IP - unlabeled                            -61.531 43.2 76  -1.426  0.9152
 Inhibitory - OtherProgenitor               86.161 61.5 76   1.401  0.9233
 Inhibitory - RadialGlia                    35.181 61.5 76   0.572  0.9999
 Inhibitory - unlabeled                     11.472 51.2 76   0.224  1.0000
 OtherProgenitor - RadialGlia              -50.980 55.0 76  -0.927  0.9951
 OtherProgenitor - unlabeled               -74.689 43.2 76  -1.731  0.7746
 RadialGlia - unlabeled                    -23.709 43.2 76  -0.549  0.9999

P value adjustment: tukey method for comparing a family of 10 estimates </code></pre>
<p>(Note that summarizing by median produces a qualitatively equivalent
result).</p>
<p>Keeping in mind that the main result of the ANOVA is that
inter-individual variation is large enough to prevent making stable
conclusions about systematic differences in cell type positions across
many samples, we can compare the average cell type distances and
responses to hypoxia (plotted above) and confirm a lack of
correlation:</p>
<pre class="r"><code>temp &lt;- data.frame(celltype=c(&quot;Cajal&quot;, &quot;Glia&quot;, &quot;Excitatory-late&quot;, &quot;IP&quot;, &quot;Excitatory-early&quot;, &quot;Inhibitory&quot;, &quot;RadialGlia&quot;),
                   order=c(1.5, 0.438, 4.24, 7.38, 4.47, 0.867, 3.38), 
                   distance_means=c(401, 298, 199, 251, 287, 317, 275),
                   distance_medians=c(351, 239, 148, 207, 237, 251, 216))

ggplot(temp, aes(x=distance_means, y=order, label=celltype)) + geom_point() + geom_text_repel() + geom_smooth(method=&quot;lm&quot;) + theme_light() + ylab(&quot;Hypoxia response magnitude&quot;)</code></pre>
<pre><code>`geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<pre><code>Warning: The following aesthetics were dropped during statistical transformation: label
ℹ This can happen when ggplot fails to infer the correct grouping structure in
  the data.
ℹ Did you forget to specify a `group` aesthetic or to convert a numerical
  variable into a factor?</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-99-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ggplot(temp, aes(x=distance_medians, y=order, label=celltype)) + geom_point() + geom_text_repel() + geom_smooth(method=&quot;lm&quot;) + theme_light() + ylab(&quot;Hypoxia response magnitude&quot;)</code></pre>
<pre><code>`geom_smooth()` using formula = &#39;y ~ x&#39;</code></pre>
<pre><code>Warning: The following aesthetics were dropped during statistical transformation: label
ℹ This can happen when ggplot fails to infer the correct grouping structure in
  the data.
ℹ Did you forget to specify a `group` aesthetic or to convert a numerical
  variable into a factor?</code></pre>
<p><img src="figure/figure2.Rmd/unnamed-chunk-99-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>summary(lm(order ~ distance_means, data = temp))</code></pre>
<pre><code>
Call:
lm(formula = order ~ distance_means, data = temp)

Residuals:
      1       2       3       4       5       6       7 
 0.9041 -2.5516 -1.0503  3.2981  1.2248 -1.6810 -0.1441 

Coefficients:
               Estimate Std. Error t value Pr(&gt;|t|)  
(Intercept)     9.91510    4.22254   2.348   0.0657 .
distance_means -0.02324    0.01430  -1.626   0.1650  
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

Residual standard error: 2.175 on 5 degrees of freedom
Multiple R-squared:  0.3458,    Adjusted R-squared:  0.2149 
F-statistic: 2.643 on 1 and 5 DF,  p-value: 0.165</code></pre>
<pre class="r"><code>summary(lm(order ~ distance_medians, data = temp))</code></pre>
<pre><code>
Call:
lm(formula = order ~ distance_medians, data = temp)

Residuals:
      1       2       3       4       5       6       7 
 0.6523 -2.6748 -0.7132  3.6200  1.3167 -2.0031 -0.1980 

Coefficients:
                 Estimate Std. Error t value Pr(&gt;|t|)  
(Intercept)       7.94637    3.75663   2.115    0.088 .
distance_medians -0.02022    0.01551  -1.304    0.249  
---
Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1

Residual standard error: 2.323 on 5 degrees of freedom
Multiple R-squared:  0.2539,    Adjusted R-squared:  0.1047 
F-statistic: 1.701 on 1 and 5 DF,  p-value: 0.2489</code></pre>
<p>This relationship also holds at the individual level, where distance
and response magnitude do not consistently correlate across individuals
for a given cell type.</p>
<br>
<p>
<button type="button" class="btn btn-default btn-workflowr btn-workflowr-sessioninfo" data-toggle="collapse" data-target="#workflowr-sessioninfo" style="display: block;">
<span class="glyphicon glyphicon-wrench" aria-hidden="true"></span>
Session information
</button>
</p>
<div id="workflowr-sessioninfo" class="collapse">
<pre class="r"><code>sessionInfo()</code></pre>
<pre><code>R version 4.2.0 (2022-04-22)
Platform: x86_64-pc-linux-gnu (64-bit)
Running under: CentOS Linux 7 (Core)

Matrix products: default
BLAS/LAPACK: /software/openblas-0.3.13-el7-x86_64/lib/libopenblas_haswellp-r0.3.13.so

locale:
 [1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C         LC_TIME=C           
 [4] LC_COLLATE=C         LC_MONETARY=C        LC_MESSAGES=C       
 [7] LC_PAPER=C           LC_NAME=C            LC_ADDRESS=C        
[10] LC_TELEPHONE=C       LC_MEASUREMENT=C     LC_IDENTIFICATION=C 

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] emmeans_1.7.3            afex_1.3-1               lme4_1.1-35.1           
 [4] Matrix_1.6-3             fgsea_1.22.0             flashier_1.0.7          
 [7] magrittr_2.0.3           ebnm_1.1-2               mixsqp_0.3-48           
[10] flashr_0.6-8             knitr_1.45               ggrepel_0.9.4           
[13] pheatmap_1.0.12          udr_0.3-153              mashr_0.2.79            
[16] ashr_2.2-63              ggbreak_0.1.2            RColorBrewer_1.1-3      
[19] pals_1.8                 forcats_0.5.1            stringr_1.5.0           
[22] dplyr_1.1.4              purrr_1.0.2              readr_2.1.4             
[25] tidyr_1.3.0              tibble_3.2.1             tidyverse_1.3.1         
[28] SeuratObject_4.1.4       Seurat_4.4.0             variancePartition_1.28.9
[31] BiocParallel_1.32.6      ggplot2_3.4.4            edgeR_3.40.2            
[34] limma_3.54.2             workflowr_1.7.0         

loaded via a namespace (and not attached):
  [1] estimability_1.3       scattermore_1.2        coda_0.19-4           
  [4] bit64_4.0.5            multcomp_1.4-19        irlba_2.3.5.1         
  [7] data.table_1.14.8      doParallel_1.0.17      generics_0.1.3        
 [10] BiocGenerics_0.44.0    TH.data_1.1-1          callr_3.7.3           
 [13] RhpcBLASctl_0.23-42    cowplot_1.1.1          RANN_2.6.1            
 [16] future_1.33.1          bit_4.0.5              tzdb_0.4.0            
 [19] horseshoe_0.2.0        spatstat.data_3.0-3    xml2_1.3.3            
 [22] lubridate_1.9.3        httpuv_1.6.5           assertthat_0.2.1      
 [25] xfun_0.41              hms_1.1.3              jquerylib_0.1.4       
 [28] evaluate_0.23          promises_1.2.0.1       fansi_1.0.5           
 [31] progress_1.2.2         caTools_1.18.2         dbplyr_2.4.0          
 [34] readxl_1.4.0           igraph_1.5.1           DBI_1.1.3             
 [37] htmlwidgets_1.6.2      spatstat.geom_3.2-7    deconvolveR_1.2-1     
 [40] ellipsis_0.3.2         backports_1.4.1        aod_1.3.2             
 [43] deldir_1.0-6           vctrs_0.6.4            Biobase_2.58.0        
 [46] ROCR_1.0-11            abind_1.4-5            cachem_1.0.8          
 [49] withr_2.5.2            progressr_0.14.0       vroom_1.6.4           
 [52] sctransform_0.4.1      prettyunits_1.1.1      goftest_1.2-3         
 [55] softImpute_1.4-1       cluster_2.1.3          pacman_0.5.1          
 [58] lazyeval_0.2.2         crayon_1.5.2           spatstat.explore_3.0-6
 [61] pkgconfig_2.0.3        labeling_0.4.3         nlme_3.1-157          
 [64] rlang_1.1.3            globals_0.16.2         lifecycle_1.0.4       
 [67] miniUI_0.1.1.1         sandwich_3.0-1         modelr_0.1.8          
 [70] dichromat_2.0-0.1      invgamma_1.1           cellranger_1.1.0      
 [73] rprojroot_2.0.3        polyclip_1.10-0        matrixStats_1.1.0     
 [76] lmtest_0.9-40          aplot_0.2.3            carData_3.0-5         
 [79] boot_1.3-28            zoo_1.8-12             reprex_2.0.1          
 [82] whisker_0.4.1          ggridges_0.5.3         processx_3.8.2        
 [85] png_0.1-8              viridisLite_0.4.2      bitops_1.0-7          
 [88] getPass_0.2-2          KernSmooth_2.23-20     SQUAREM_2021.1        
 [91] parallelly_1.37.0      spatstat.random_3.1-3  remaCor_0.0.16        
 [94] gridGraphics_0.5-1     rmeta_3.0              scales_1.2.1          
 [97] memoise_2.0.1          plyr_1.8.9             ica_1.0-3             
[100] gplots_3.1.3           compiler_4.2.0         fitdistrplus_1.1-8    
[103] cli_3.6.1              lmerTest_3.1-3         listenv_0.9.1         
[106] patchwork_1.1.3        pbapply_1.5-0          ps_1.7.5              
[109] mgcv_1.8-40            MASS_7.3-56            tidyselect_1.2.0      
[112] stringi_1.8.1          highr_0.9              yaml_2.3.5            
[115] locfit_1.5-9.8         grid_4.2.0             sass_0.4.7            
[118] fastmatch_1.1-3        tools_4.2.0            timechange_0.2.0      
[121] future.apply_1.11.1    parallel_4.2.0         rstudioapi_0.13       
[124] foreach_1.5.2          git2r_0.30.1           gridExtra_2.3         
[127] trust_0.1-8            EnvStats_2.8.1         farver_2.1.1          
[130] Rtsne_0.16             digest_0.6.34          shiny_1.7.5.1         
[133] Rcpp_1.0.12            car_3.1-2              broom_1.0.5           
[136] later_1.3.0            RcppAnnoy_0.0.19       httr_1.4.7            
[139] Rdpack_2.6             colorspace_2.1-0       rvest_1.0.2           
[142] fs_1.6.3               tensor_1.5             reticulate_1.34.0     
[145] truncnorm_1.0-9        splines_4.2.0          uwot_0.1.16           
[148] yulab.utils_0.1.0      spatstat.utils_3.0-4   sp_2.1-3              
[151] mapproj_1.2.11         ggplotify_0.1.2        plotly_4.10.0         
[154] xtable_1.8-4           jsonlite_1.8.7         nloptr_2.0.3          
[157] ggfun_0.1.5            R6_2.5.1               pillar_1.9.0          
[160] htmltools_0.5.7        mime_0.12              glue_1.6.2            
[163] fastmap_1.1.1          minqa_1.2.6            codetools_0.2-18      
[166] maps_3.4.0             mvtnorm_1.2-3          utf8_1.2.4            
[169] lattice_0.20-45        bslib_0.5.1            spatstat.sparse_3.0-3 
[172] numDeriv_2016.8-1.1    pbkrtest_0.5.2         leiden_0.4.2          
[175] gtools_3.9.4           survival_3.3-1         rmarkdown_2.26        
[178] munsell_0.5.0          iterators_1.0.14       haven_2.5.0           
[181] reshape2_1.4.4         gtable_0.3.4           rbibutils_2.2.16      </code></pre>
</div>
</div>


<!-- Adjust MathJax settings so that all math formulae are shown using
TeX fonts only; see
https://docs.mathjax.org/en/latest/web/configuration.html. This will make
the presentation more consistent at the cost of the webpage sometimes
taking slightly longer to load. Note that this only works because the
footer is added to webpages before the MathJax javascript. -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    "HTML-CSS": { availableFonts: ["TeX"] }
  });
</script>




</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
